
out/psoc6_cm4.elf:     file format elf32-littlearm


Disassembly of section .text:

10002000 <__Vectors>:
10002000:	080ff800 	.word	0x080ff800
10002004:	10002325 	.word	0x10002325
10002008:	0000000d 	.word	0x0000000d
1000200c:	10002399 	.word	0x10002399
10002010:	10002399 	.word	0x10002399
10002014:	10002399 	.word	0x10002399
10002018:	10002399 	.word	0x10002399
	...
1000202c:	10002395 	.word	0x10002395
10002030:	10002395 	.word	0x10002395
10002034:	00000000 	.word	0x00000000
10002038:	10002395 	.word	0x10002395
1000203c:	10002395 	.word	0x10002395
10002040:	10002395 	.word	0x10002395
10002044:	10002395 	.word	0x10002395
10002048:	10002395 	.word	0x10002395
1000204c:	10002395 	.word	0x10002395
10002050:	10002395 	.word	0x10002395
10002054:	10002395 	.word	0x10002395
10002058:	10002395 	.word	0x10002395
1000205c:	10002395 	.word	0x10002395
10002060:	10002395 	.word	0x10002395
10002064:	10002395 	.word	0x10002395
10002068:	10002395 	.word	0x10002395
1000206c:	10002395 	.word	0x10002395
10002070:	10002395 	.word	0x10002395
10002074:	10002395 	.word	0x10002395
10002078:	10002395 	.word	0x10002395
1000207c:	10002395 	.word	0x10002395
10002080:	10002395 	.word	0x10002395
10002084:	10002395 	.word	0x10002395
10002088:	10002395 	.word	0x10002395
1000208c:	10002395 	.word	0x10002395
10002090:	10002395 	.word	0x10002395
10002094:	10002395 	.word	0x10002395
10002098:	10002395 	.word	0x10002395
1000209c:	10002395 	.word	0x10002395
100020a0:	10002395 	.word	0x10002395
100020a4:	10002395 	.word	0x10002395
100020a8:	10002395 	.word	0x10002395
100020ac:	10002395 	.word	0x10002395
100020b0:	10002395 	.word	0x10002395
100020b4:	10002395 	.word	0x10002395
100020b8:	10002395 	.word	0x10002395
100020bc:	10002395 	.word	0x10002395
100020c0:	10002395 	.word	0x10002395
100020c4:	10002395 	.word	0x10002395
100020c8:	10002395 	.word	0x10002395
100020cc:	10002395 	.word	0x10002395
100020d0:	10002395 	.word	0x10002395
100020d4:	10002395 	.word	0x10002395
100020d8:	10002395 	.word	0x10002395
100020dc:	10002395 	.word	0x10002395
100020e0:	10002395 	.word	0x10002395
100020e4:	10002395 	.word	0x10002395
100020e8:	10002395 	.word	0x10002395
100020ec:	10002395 	.word	0x10002395
100020f0:	10002395 	.word	0x10002395
100020f4:	10002395 	.word	0x10002395
100020f8:	10002395 	.word	0x10002395
100020fc:	10002395 	.word	0x10002395
10002100:	10002395 	.word	0x10002395
10002104:	10002395 	.word	0x10002395
10002108:	10002395 	.word	0x10002395
1000210c:	10002395 	.word	0x10002395
10002110:	10002395 	.word	0x10002395
10002114:	10002395 	.word	0x10002395
10002118:	10002395 	.word	0x10002395
1000211c:	10002395 	.word	0x10002395
10002120:	10002395 	.word	0x10002395
10002124:	10002395 	.word	0x10002395
10002128:	10002395 	.word	0x10002395
1000212c:	10002395 	.word	0x10002395
10002130:	10002395 	.word	0x10002395
10002134:	10002395 	.word	0x10002395
10002138:	10002395 	.word	0x10002395
1000213c:	10002395 	.word	0x10002395
10002140:	10002395 	.word	0x10002395
10002144:	10002395 	.word	0x10002395
10002148:	10002395 	.word	0x10002395
1000214c:	10002395 	.word	0x10002395
10002150:	10002395 	.word	0x10002395
10002154:	10002395 	.word	0x10002395
10002158:	10002395 	.word	0x10002395
1000215c:	10002395 	.word	0x10002395
10002160:	10002395 	.word	0x10002395
10002164:	10002395 	.word	0x10002395
10002168:	10002395 	.word	0x10002395
1000216c:	10002395 	.word	0x10002395
10002170:	10002395 	.word	0x10002395
10002174:	10002395 	.word	0x10002395
10002178:	10002395 	.word	0x10002395
1000217c:	10002395 	.word	0x10002395
10002180:	10002395 	.word	0x10002395
10002184:	10002395 	.word	0x10002395
10002188:	10002395 	.word	0x10002395
1000218c:	10002395 	.word	0x10002395
10002190:	10002395 	.word	0x10002395
10002194:	10002395 	.word	0x10002395
10002198:	10002395 	.word	0x10002395
1000219c:	10002395 	.word	0x10002395
100021a0:	10002395 	.word	0x10002395
100021a4:	10002395 	.word	0x10002395
100021a8:	10002395 	.word	0x10002395
100021ac:	10002395 	.word	0x10002395
100021b0:	10002395 	.word	0x10002395
100021b4:	10002395 	.word	0x10002395
100021b8:	10002395 	.word	0x10002395
100021bc:	10002395 	.word	0x10002395
100021c0:	10002395 	.word	0x10002395
100021c4:	10002395 	.word	0x10002395
100021c8:	10002395 	.word	0x10002395
100021cc:	10002395 	.word	0x10002395
100021d0:	10002395 	.word	0x10002395
100021d4:	10002395 	.word	0x10002395
100021d8:	10002395 	.word	0x10002395
100021dc:	10002395 	.word	0x10002395
100021e0:	10002395 	.word	0x10002395
100021e4:	10002395 	.word	0x10002395
100021e8:	10002395 	.word	0x10002395
100021ec:	10002395 	.word	0x10002395
100021f0:	10002395 	.word	0x10002395
100021f4:	10002395 	.word	0x10002395
100021f8:	10002395 	.word	0x10002395
100021fc:	10002395 	.word	0x10002395
10002200:	10002395 	.word	0x10002395
10002204:	10002395 	.word	0x10002395
10002208:	10002395 	.word	0x10002395
1000220c:	10002395 	.word	0x10002395
10002210:	10002395 	.word	0x10002395
10002214:	10002395 	.word	0x10002395
10002218:	10002395 	.word	0x10002395
1000221c:	10002395 	.word	0x10002395
10002220:	10002395 	.word	0x10002395
10002224:	10002395 	.word	0x10002395
10002228:	10002395 	.word	0x10002395
1000222c:	10002395 	.word	0x10002395
10002230:	10002395 	.word	0x10002395
10002234:	10002395 	.word	0x10002395
10002238:	10002395 	.word	0x10002395
1000223c:	10002395 	.word	0x10002395
10002240:	10002395 	.word	0x10002395
10002244:	10002395 	.word	0x10002395
10002248:	10002395 	.word	0x10002395
1000224c:	10002395 	.word	0x10002395
10002250:	10002395 	.word	0x10002395
10002254:	10002395 	.word	0x10002395
10002258:	10002395 	.word	0x10002395
1000225c:	10002395 	.word	0x10002395
10002260:	10002395 	.word	0x10002395
10002264:	10002395 	.word	0x10002395
10002268:	10002395 	.word	0x10002395
1000226c:	10002395 	.word	0x10002395
10002270:	10002395 	.word	0x10002395
10002274:	10002395 	.word	0x10002395
10002278:	10002395 	.word	0x10002395
1000227c:	10002395 	.word	0x10002395
10002280:	10002395 	.word	0x10002395
10002284:	10002395 	.word	0x10002395
10002288:	10002395 	.word	0x10002395
1000228c:	10002395 	.word	0x10002395
10002290:	10002395 	.word	0x10002395
10002294:	10002395 	.word	0x10002395
10002298:	10002395 	.word	0x10002395
1000229c:	10002395 	.word	0x10002395
100022a0:	10002395 	.word	0x10002395
100022a4:	10002395 	.word	0x10002395
100022a8:	10002395 	.word	0x10002395
100022ac:	10002395 	.word	0x10002395
100022b0:	10002395 	.word	0x10002395
100022b4:	10002395 	.word	0x10002395
100022b8:	10002395 	.word	0x10002395
100022bc:	10002395 	.word	0x10002395
100022c0:	10002395 	.word	0x10002395
100022c4:	10002395 	.word	0x10002395
100022c8:	10002395 	.word	0x10002395
100022cc:	10002395 	.word	0x10002395
100022d0:	10002395 	.word	0x10002395
100022d4:	10002395 	.word	0x10002395
100022d8:	10002395 	.word	0x10002395
100022dc:	10002395 	.word	0x10002395

100022e0 <__do_global_dtors_aux>:
100022e0:	b510      	push	{r4, lr}
100022e2:	4c05      	ldr	r4, [pc, #20]	; (100022f8 <__do_global_dtors_aux+0x18>)
100022e4:	7823      	ldrb	r3, [r4, #0]
100022e6:	b933      	cbnz	r3, 100022f6 <__do_global_dtors_aux+0x16>
100022e8:	4b04      	ldr	r3, [pc, #16]	; (100022fc <__do_global_dtors_aux+0x1c>)
100022ea:	b113      	cbz	r3, 100022f2 <__do_global_dtors_aux+0x12>
100022ec:	4804      	ldr	r0, [pc, #16]	; (10002300 <__do_global_dtors_aux+0x20>)
100022ee:	f3af 8000 	nop.w
100022f2:	2301      	movs	r3, #1
100022f4:	7023      	strb	r3, [r4, #0]
100022f6:	bd10      	pop	{r4, pc}
100022f8:	0800239c 	.word	0x0800239c
100022fc:	00000000 	.word	0x00000000
10002300:	10003474 	.word	0x10003474

10002304 <frame_dummy>:
10002304:	b508      	push	{r3, lr}
10002306:	4b03      	ldr	r3, [pc, #12]	; (10002314 <frame_dummy+0x10>)
10002308:	b11b      	cbz	r3, 10002312 <frame_dummy+0xe>
1000230a:	4903      	ldr	r1, [pc, #12]	; (10002318 <frame_dummy+0x14>)
1000230c:	4803      	ldr	r0, [pc, #12]	; (1000231c <frame_dummy+0x18>)
1000230e:	f3af 8000 	nop.w
10002312:	bd08      	pop	{r3, pc}
10002314:	00000000 	.word	0x00000000
10002318:	080023a0 	.word	0x080023a0
1000231c:	10003474 	.word	0x10003474

10002320 <Cy_OnResetUser>:
    .weak   Cy_OnResetUser
    .func   Cy_OnResetUser, Cy_OnResetUser
    .type   Cy_OnResetUser, %function

Cy_OnResetUser:
    bx lr
10002320:	4770      	bx	lr

10002322 <cy_toolchain_init>:
    .weak   cy_toolchain_init
    .func   cy_toolchain_init, cy_toolchain_init
    .type   cy_toolchain_init, %function

cy_toolchain_init:
    bx lr
10002322:	4770      	bx	lr

10002324 <Reset_Handler>:
    /* Reset handler */
    .weak    Reset_Handler
    .type    Reset_Handler, %function

Reset_Handler:
    bl Cy_OnResetUser
10002324:	f7ff fffc 	bl	10002320 <Cy_OnResetUser>
    cpsid i
10002328:	b672      	cpsid	i
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr    r4, =__copy_table_start__
1000232a:	4c14      	ldr	r4, [pc, #80]	; (1000237c <Reset_Handler+0x58>)
    ldr    r5, =__copy_table_end__
1000232c:	4d14      	ldr	r5, [pc, #80]	; (10002380 <Reset_Handler+0x5c>)

.L_loop0:
    cmp    r4, r5
1000232e:	42ac      	cmp	r4, r5
    bge    .L_loop0_done
10002330:	da09      	bge.n	10002346 <Reset_Handler+0x22>
    ldr    r1, [r4]
10002332:	6821      	ldr	r1, [r4, #0]
    ldr    r2, [r4, #4]
10002334:	6862      	ldr	r2, [r4, #4]
    ldr    r3, [r4, #8]
10002336:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
    subs    r3, #4
10002338:	3b04      	subs	r3, #4
    ittt    ge
1000233a:	bfa2      	ittt	ge
    ldrge    r0, [r1, r3]
1000233c:	58c8      	ldrge	r0, [r1, r3]
    strge    r0, [r2, r3]
1000233e:	50d0      	strge	r0, [r2, r3]
    bge    .L_loop0_0
10002340:	e7fa      	bge.n	10002338 <Reset_Handler+0x14>

    adds    r4, #12
10002342:	340c      	adds	r4, #12
    b    .L_loop0
10002344:	e7f3      	b.n	1000232e <Reset_Handler+0xa>
 *    __bss_start__: start of the BSS section.
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
    ldr    r1, =__bss_start__
10002346:	490f      	ldr	r1, [pc, #60]	; (10002384 <Reset_Handler+0x60>)
    ldr    r2, =__bss_end__
10002348:	4a0f      	ldr	r2, [pc, #60]	; (10002388 <Reset_Handler+0x64>)

    movs    r0, 0
1000234a:	2000      	movs	r0, #0
.L_loop3:
    cmp    r1, r2
1000234c:	4291      	cmp	r1, r2
    itt    lt
1000234e:	bfbc      	itt	lt
    strlt    r0, [r1], #4
10002350:	f841 0b04 	strlt.w	r0, [r1], #4
    blt    .L_loop3
10002354:	e7fa      	blt.n	1000234c <Reset_Handler+0x28>
#endif /* __STARTUP_CLEAR_BSS_MULTIPLE || __STARTUP_CLEAR_BSS */

    /* Update Vector Table Offset Register. */
    ldr r0, =__ramVectors
10002356:	480d      	ldr	r0, [pc, #52]	; (1000238c <Reset_Handler+0x68>)
    ldr r1, =CY_CPU_VTOR_ADDR
10002358:	490d      	ldr	r1, [pc, #52]	; (10002390 <Reset_Handler+0x6c>)
    str r0, [r1]
1000235a:	6008      	str	r0, [r1, #0]
    dsb 0xF
1000235c:	f3bf 8f4f 	dsb	sy

    /* Enable the FPU if used */
    bl Cy_SystemInitFpuEnable
10002360:	f000 f882 	bl	10002468 <Cy_SystemInitFpuEnable>

#ifndef __NO_SYSTEM_INIT
    bl    SystemInit
10002364:	f000 f874 	bl	10002450 <SystemInit>
#endif

    /* OS-specific low-level initialization */
    bl    cy_toolchain_init
10002368:	f7ff ffdb 	bl	10002322 <cy_toolchain_init>

    /* Call C/C++ static constructors */
    bl    __libc_init_array
1000236c:	f000 ffc8 	bl	10003300 <__libc_init_array>

    /* Execute main application */
    bl    main
10002370:	f000 fdda 	bl	10002f28 <main>

    /* Call C/C++ static destructors */
    bl    __libc_fini_array
10002374:	f000 ffb0 	bl	100032d8 <__libc_fini_array>

    /* Should never get here */
    b   .
10002378:	e7fe      	b.n	10002378 <Reset_Handler+0x54>
1000237a:	0000      	.short	0x0000
    ldr    r4, =__copy_table_start__
1000237c:	10003480 	.word	0x10003480
    ldr    r5, =__copy_table_end__
10002380:	10003498 	.word	0x10003498
    ldr    r1, =__bss_start__
10002384:	0800239c 	.word	0x0800239c
    ldr    r2, =__bss_end__
10002388:	08002400 	.word	0x08002400
    ldr r0, =__ramVectors
1000238c:	08002000 	.word	0x08002000
    ldr r1, =CY_CPU_VTOR_ADDR
10002390:	e000ed08 	.word	0xe000ed08

10002394 <DebugMon_Handler>:
    .thumb_func
    .weak    Default_Handler
    .type    Default_Handler, %function

Default_Handler:
    b    .
10002394:	e7fe      	b.n	10002394 <DebugMon_Handler>

    .weak    Cy_SysLib_FaultHandler
    .type    Cy_SysLib_FaultHandler, %function
    
Cy_SysLib_FaultHandler:
    b    .
10002396:	e7fe      	b.n	10002396 <DebugMon_Handler+0x2>

10002398 <BusFault_Handler>:
    .size    Cy_SysLib_FaultHandler, . - Cy_SysLib_FaultHandler
    .type Fault_Handler, %function

Fault_Handler:
    /* Storing LR content for Creator call stack trace */
    push {LR}
10002398:	b500      	push	{lr}
    movs r0, #4
1000239a:	2004      	movs	r0, #4
    mov r1, LR
1000239c:	4671      	mov	r1, lr
    tst r0, r1
1000239e:	4208      	tst	r0, r1
    beq .L_MSP
100023a0:	d002      	beq.n	100023a8 <BusFault_Handler+0x10>
    mrs r0, PSP
100023a2:	f3ef 8009 	mrs	r0, PSP
    b .L_API_call
100023a6:	e002      	b.n	100023ae <BusFault_Handler+0x16>
.L_MSP:
    mrs r0, MSP
100023a8:	f3ef 8008 	mrs	r0, MSP
    /* Compensation of stack pointer address due to pushing 4 bytes of LR */
    adds r0, r0, #4
100023ac:	3004      	adds	r0, #4
.L_API_call:
    bl Cy_SysLib_FaultHandler
100023ae:	f000 f8e5 	bl	1000257c <Cy_SysLib_FaultHandler>
    b   .
100023b2:	e7fe      	b.n	100023b2 <BusFault_Handler+0x1a>
100023b4:	0000      	movs	r0, r0
	...

100023b8 <Cy_SysLib_DelayCycles>:
.func Cy_SysLib_DelayCycles, Cy_SysLib_DelayCycles
.type Cy_SysLib_DelayCycles, %function
.thumb_func
Cy_SysLib_DelayCycles:      /* cycles bytes */

    ADDS r0, r0, #2         /*    1    2    Round to nearest multiple of 4 */
100023b8:	3002      	adds	r0, #2
    LSRS r0, r0, #2         /*    1    2    Divide by 4 and set flags */
100023ba:	0880      	lsrs	r0, r0, #2
    BEQ Cy_DelayCycles_done /*    2    2    Skip if 0 */
100023bc:	d003      	beq.n	100023c6 <Cy_DelayCycles_done>

100023be <Cy_DelayCycles_loop>:

Cy_DelayCycles_loop:
    ADDS r0, r0, #1         /*    1    2    Increment counter */
100023be:	3001      	adds	r0, #1
    SUBS r0, r0, #2         /*    1    2    Decrement counter by 2 */
100023c0:	3802      	subs	r0, #2
    BNE Cy_DelayCycles_loop /*   (1)2  2    2 CPU cycles (if branch is taken) */
100023c2:	d1fc      	bne.n	100023be <Cy_DelayCycles_loop>
    NOP                     /*    1    2    Loop alignment padding */
100023c4:	bf00      	nop

100023c6 <Cy_DelayCycles_done>:

Cy_DelayCycles_done:
    NOP                     /*    1    2    Loop alignment padding */
100023c6:	bf00      	nop
    BX lr                   /*    3    2 */
100023c8:	4770      	bx	lr

100023ca <Cy_SysLib_EnterCriticalSection>:
.func Cy_SysLib_EnterCriticalSection, Cy_SysLib_EnterCriticalSection
.type Cy_SysLib_EnterCriticalSection, %function
.thumb_func

Cy_SysLib_EnterCriticalSection:
    MRS r0, PRIMASK         /* Save and return interrupt state */
100023ca:	f3ef 8010 	mrs	r0, PRIMASK
    cpsid i                 /* Disable interrupts */
100023ce:	b672      	cpsid	i
    BX lr
100023d0:	4770      	bx	lr

100023d2 <Cy_SysLib_ExitCriticalSection>:
.func Cy_SysLib_ExitCriticalSection, Cy_SysLib_ExitCriticalSection
.type Cy_SysLib_ExitCriticalSection, %function
.thumb_func

Cy_SysLib_ExitCriticalSection:
    MSR PRIMASK, r0         /* Restore interrupt state */
100023d2:	f380 8810 	msr	PRIMASK, r0
    BX lr
100023d6:	4770      	bx	lr

100023d8 <Cy_SystemInit>:
__WEAK void Cy_SystemInit(void)
{
     /* Empty weak function. The actual implementation to be in the PSoC Creator
      * generated strong function.
     */
}
100023d8:	4770      	bx	lr
	...

100023dc <SystemCoreClockUpdate>:
* Updates global variables used by the \ref Cy_SysLib_Delay(), \ref
* Cy_SysLib_DelayUs(), and \ref Cy_SysLib_DelayCycles().
*
*******************************************************************************/
void SystemCoreClockUpdate (void)
{
100023dc:	b510      	push	{r4, lr}
    uint32 locHf0Clock = Cy_SysClk_ClkHfGetFrequency(0UL);
100023de:	2000      	movs	r0, #0
100023e0:	f000 fbd0 	bl	10002b84 <Cy_SysClk_ClkHfGetFrequency>

    if (0UL != locHf0Clock)
100023e4:	b900      	cbnz	r0, 100023e8 <SystemCoreClockUpdate+0xc>
        /* Sets clock frequency for Delay API */
        cy_delayFreqMhz = (uint8_t)CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1M_THRESHOLD);
        cy_delayFreqKhz = CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1K_THRESHOLD);
        cy_delay32kMs   = CY_DELAY_MS_OVERFLOW_THRESHOLD * cy_delayFreqKhz;
    }
}
100023e6:	bd10      	pop	{r4, pc}
100023e8:	4604      	mov	r4, r0
        cy_Hfclk0FreqHz = locHf0Clock;
100023ea:	4b11      	ldr	r3, [pc, #68]	; (10002430 <SystemCoreClockUpdate+0x54>)
100023ec:	6018      	str	r0, [r3, #0]
        cy_PeriClkFreqHz = locHf0Clock / (1UL + (uint32_t)Cy_SysClk_ClkPeriGetDivider());
100023ee:	f000 f9d7 	bl	100027a0 <Cy_SysClk_ClkPeriGetDivider>
100023f2:	3001      	adds	r0, #1
100023f4:	fbb4 f0f0 	udiv	r0, r4, r0
100023f8:	4b0e      	ldr	r3, [pc, #56]	; (10002434 <SystemCoreClockUpdate+0x58>)
100023fa:	6018      	str	r0, [r3, #0]
        SystemCoreClock = locHf0Clock / (1UL + (uint32_t)Cy_SysClk_ClkFastGetDivider());
100023fc:	f000 f9da 	bl	100027b4 <Cy_SysClk_ClkFastGetDivider>
10002400:	3001      	adds	r0, #1
10002402:	fbb4 f4f0 	udiv	r4, r4, r0
10002406:	4b0c      	ldr	r3, [pc, #48]	; (10002438 <SystemCoreClockUpdate+0x5c>)
10002408:	601c      	str	r4, [r3, #0]
        cy_delayFreqMhz = (uint8_t)CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1M_THRESHOLD);
1000240a:	3c01      	subs	r4, #1
1000240c:	4b0b      	ldr	r3, [pc, #44]	; (1000243c <SystemCoreClockUpdate+0x60>)
1000240e:	fba3 2304 	umull	r2, r3, r3, r4
10002412:	0c9b      	lsrs	r3, r3, #18
10002414:	3301      	adds	r3, #1
10002416:	4a0a      	ldr	r2, [pc, #40]	; (10002440 <SystemCoreClockUpdate+0x64>)
10002418:	7013      	strb	r3, [r2, #0]
        cy_delayFreqKhz = CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1K_THRESHOLD);
1000241a:	4b0a      	ldr	r3, [pc, #40]	; (10002444 <SystemCoreClockUpdate+0x68>)
1000241c:	fba3 2304 	umull	r2, r3, r3, r4
10002420:	099b      	lsrs	r3, r3, #6
10002422:	3301      	adds	r3, #1
10002424:	4a08      	ldr	r2, [pc, #32]	; (10002448 <SystemCoreClockUpdate+0x6c>)
10002426:	6013      	str	r3, [r2, #0]
        cy_delay32kMs   = CY_DELAY_MS_OVERFLOW_THRESHOLD * cy_delayFreqKhz;
10002428:	03db      	lsls	r3, r3, #15
1000242a:	4a08      	ldr	r2, [pc, #32]	; (1000244c <SystemCoreClockUpdate+0x70>)
1000242c:	6013      	str	r3, [r2, #0]
}
1000242e:	e7da      	b.n	100023e6 <SystemCoreClockUpdate+0xa>
10002430:	080022e4 	.word	0x080022e4
10002434:	080022e8 	.word	0x080022e8
10002438:	080022e0 	.word	0x080022e0
1000243c:	431bde83 	.word	0x431bde83
10002440:	080022f4 	.word	0x080022f4
10002444:	10624dd3 	.word	0x10624dd3
10002448:	080022f0 	.word	0x080022f0
1000244c:	080022ec 	.word	0x080022ec

10002450 <SystemInit>:
{
10002450:	b508      	push	{r3, lr}
    Cy_PDL_Init(CY_DEVICE_CFG);
10002452:	4804      	ldr	r0, [pc, #16]	; (10002464 <SystemInit+0x14>)
10002454:	f000 fba6 	bl	10002ba4 <Cy_PDL_Init>
    Cy_SystemInit();
10002458:	f7ff ffbe 	bl	100023d8 <Cy_SystemInit>
    SystemCoreClockUpdate();
1000245c:	f7ff ffbe 	bl	100023dc <SystemCoreClockUpdate>
}
10002460:	bd08      	pop	{r3, pc}
10002462:	bf00      	nop
10002464:	10003360 	.word	0x10003360

10002468 <Cy_SystemInitFpuEnable>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10002468:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
1000246c:	b672      	cpsid	i
{
    #if defined (__FPU_USED) && (__FPU_USED == 1U)
        uint32_t  interruptState;
        interruptState = __get_PRIMASK();
        __disable_irq();
        SCB->CPACR |= SCB_CPACR_CP10_CP11_ENABLE;
1000246e:	4a07      	ldr	r2, [pc, #28]	; (1000248c <Cy_SystemInitFpuEnable+0x24>)
10002470:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
10002474:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
10002478:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
1000247c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
10002480:	f3bf 8f6f 	isb	sy
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10002484:	f381 8810 	msr	PRIMASK, r1
        __DSB();
        __ISB();
        __set_PRIMASK(interruptState);
    #endif /* (__FPU_USED) && (__FPU_USED == 1U) */
}
10002488:	4770      	bx	lr
1000248a:	bf00      	nop
1000248c:	e000ed00 	.word	0xe000ed00

10002490 <Cy_GPIO_SetHSIOM>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetHSIOM
*
*******************************************************************************/
void Cy_GPIO_SetHSIOM(GPIO_PRT_Type* base, uint32_t pinNum, en_hsiom_sel_t value)
{
10002490:	b510      	push	{r4, lr}

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10002492:	2907      	cmp	r1, #7
10002494:	d900      	bls.n	10002498 <Cy_GPIO_SetHSIOM+0x8>

/** Halt the processor in the debug state
 */
static inline void CY_HALT(void)
{
    __asm("    bkpt    1");
10002496:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_HSIOM_VALID(value));
10002498:	f032 031f 	bics.w	r3, r2, #31
1000249c:	d000      	beq.n	100024a0 <Cy_GPIO_SetHSIOM+0x10>
1000249e:	be01      	bkpt	0x0001

    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
100024a0:	4b16      	ldr	r3, [pc, #88]	; (100024fc <Cy_GPIO_SetHSIOM+0x6c>)
100024a2:	681b      	ldr	r3, [r3, #0]
100024a4:	699c      	ldr	r4, [r3, #24]
100024a6:	1b00      	subs	r0, r0, r4
100024a8:	09c0      	lsrs	r0, r0, #7
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
100024aa:	695b      	ldr	r3, [r3, #20]
100024ac:	ea4f 1c00 	mov.w	ip, r0, lsl #4
100024b0:	eb03 1000 	add.w	r0, r3, r0, lsl #4

    #if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
        pinType = CY_PRA_GET_PIN_PROT_TYPE(base, pinNum);
    #endif

    if(pinNum < CY_GPIO_PRT_HALF)
100024b4:	2903      	cmp	r1, #3
100024b6:	d810      	bhi.n	100024da <Cy_GPIO_SetHSIOM+0x4a>
        {
            /* secure pin */
            tempReg = 0UL;
        }
    #else
        tempReg = HSIOM_PRT_PORT_SEL0(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
100024b8:	f853 000c 	ldr.w	r0, [r3, ip]
100024bc:	00c9      	lsls	r1, r1, #3
100024be:	f04f 0e1f 	mov.w	lr, #31
100024c2:	fa0e fe01 	lsl.w	lr, lr, r1
100024c6:	ea20 000e 	bic.w	r0, r0, lr
    #endif
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
100024ca:	f002 021f 	and.w	r2, r2, #31
100024ce:	fa02 f101 	lsl.w	r1, r2, r1
100024d2:	4301      	orrs	r1, r0
        else
        {
            /* Secure PIN can't be modified using register policy */
        }
    #else
        HSIOM_PRT_PORT_SEL0(portAddrHSIOM) = hsiomReg;
100024d4:	f843 100c 	str.w	r1, [r3, ip]
        }
    #else
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
    #endif
    }
}
100024d8:	bd10      	pop	{r4, pc}
        pinNum -= CY_GPIO_PRT_HALF;
100024da:	3904      	subs	r1, #4
        tempReg = HSIOM_PRT_PORT_SEL1(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
100024dc:	6843      	ldr	r3, [r0, #4]
100024de:	00c9      	lsls	r1, r1, #3
100024e0:	f04f 0c1f 	mov.w	ip, #31
100024e4:	fa0c fc01 	lsl.w	ip, ip, r1
100024e8:	ea23 030c 	bic.w	r3, r3, ip
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
100024ec:	f002 021f 	and.w	r2, r2, #31
100024f0:	fa02 f101 	lsl.w	r1, r2, r1
100024f4:	4319      	orrs	r1, r3
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
100024f6:	6041      	str	r1, [r0, #4]
}
100024f8:	e7ee      	b.n	100024d8 <Cy_GPIO_SetHSIOM+0x48>
100024fa:	bf00      	nop
100024fc:	080023c0 	.word	0x080023c0

10002500 <Cy_GPIO_SetDrivemode>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetDrivemode
*
*******************************************************************************/
void Cy_GPIO_SetDrivemode(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10002500:	b500      	push	{lr}
    uint32_t prtCfg;
#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10002502:	2907      	cmp	r1, #7
10002504:	d900      	bls.n	10002508 <Cy_GPIO_SetDrivemode+0x8>
10002506:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_DM_VALID(value));
10002508:	f032 030f 	bics.w	r3, r2, #15
1000250c:	d103      	bne.n	10002516 <Cy_GPIO_SetDrivemode+0x16>
1000250e:	2a01      	cmp	r2, #1
10002510:	d001      	beq.n	10002516 <Cy_GPIO_SetDrivemode+0x16>
10002512:	2a09      	cmp	r2, #9
10002514:	d100      	bne.n	10002518 <Cy_GPIO_SetDrivemode+0x18>
10002516:	be01      	bkpt	0x0001

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    pinType = CY_PRA_GET_PIN_PROT_TYPE(base, pinNum);
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    pinLoc = pinNum << CY_GPIO_DRIVE_MODE_OFFSET;
10002518:	0089      	lsls	r1, r1, #2
    {
        /* secure pin */
        tempReg = 0;
    }
#else
    tempReg = (GPIO_PRT_CFG(base) & ~(CY_GPIO_CFG_DM_MASK << pinLoc));
1000251a:	4b0a      	ldr	r3, [pc, #40]	; (10002544 <Cy_GPIO_SetDrivemode+0x44>)
1000251c:	681b      	ldr	r3, [r3, #0]
1000251e:	f893 e081 	ldrb.w	lr, [r3, #129]	; 0x81
10002522:	f85e 3000 	ldr.w	r3, [lr, r0]
10002526:	f04f 0c0f 	mov.w	ip, #15
1000252a:	fa0c fc01 	lsl.w	ip, ip, r1
1000252e:	ea23 030c 	bic.w	r3, r3, ip
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2) */
    prtCfg = tempReg | ((value & CY_GPIO_CFG_DM_MASK) << pinLoc);
10002532:	f002 020f 	and.w	r2, r2, #15
10002536:	408a      	lsls	r2, r1
10002538:	431a      	orrs	r2, r3
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_CFG(base) = prtCfg;
1000253a:	f84e 2000 	str.w	r2, [lr, r0]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
1000253e:	f85d fb04 	ldr.w	pc, [sp], #4
10002542:	bf00      	nop
10002544:	080023c0 	.word	0x080023c0

10002548 <Cy_SysLib_Delay>:
#ifndef CY_SYSLIB_DELAY_CALIBRATION_FACTOR
#define CY_SYSLIB_DELAY_CALIBRATION_FACTOR     1U
#endif

void Cy_SysLib_Delay(uint32_t milliseconds)
{
10002548:	b510      	push	{r4, lr}
1000254a:	4604      	mov	r4, r0
    while(milliseconds > CY_DELAY_MS_OVERFLOW)
1000254c:	e005      	b.n	1000255a <Cy_SysLib_Delay+0x12>
    {
        /* This loop prevents an overflow in value passed to Cy_SysLib_DelayCycles() API.
         * At 100 MHz, (milliseconds * cy_delayFreqKhz) product overflows
         * in case if milliseconds parameter is more than 42 seconds.
         */
        Cy_SysLib_DelayCycles(cy_delay32kMs);
1000254e:	4b08      	ldr	r3, [pc, #32]	; (10002570 <Cy_SysLib_Delay+0x28>)
10002550:	6818      	ldr	r0, [r3, #0]
10002552:	f7ff ff31 	bl	100023b8 <Cy_SysLib_DelayCycles>
        milliseconds -= CY_DELAY_MS_OVERFLOW;
10002556:	f5a4 4400 	sub.w	r4, r4, #32768	; 0x8000
    while(milliseconds > CY_DELAY_MS_OVERFLOW)
1000255a:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
1000255e:	d8f6      	bhi.n	1000254e <Cy_SysLib_Delay+0x6>
    }

    Cy_SysLib_DelayCycles(milliseconds * cy_delayFreqKhz * CY_SYSLIB_DELAY_CALIBRATION_FACTOR);
10002560:	4b04      	ldr	r3, [pc, #16]	; (10002574 <Cy_SysLib_Delay+0x2c>)
10002562:	6818      	ldr	r0, [r3, #0]
10002564:	fb04 f000 	mul.w	r0, r4, r0
10002568:	f7ff ff26 	bl	100023b8 <Cy_SysLib_DelayCycles>
}
1000256c:	bd10      	pop	{r4, pc}
1000256e:	bf00      	nop
10002570:	080022ec 	.word	0x080022ec
10002574:	080022f0 	.word	0x080022f0

10002578 <Cy_SysLib_ProcessingFault>:
         * Otherwise, the compiler destroys the call stack,
         * because treats this API as a no return function.
         */
        Cy_SysLib_AsmInfiniteLoop();
    #else
        while(true) {}
10002578:	e7fe      	b.n	10002578 <Cy_SysLib_ProcessingFault>
	...

1000257c <Cy_SysLib_FaultHandler>:
{
1000257c:	b508      	push	{r3, lr}
    cy_faultFrame.r0  = faultStackAddr[CY_R0_Pos];
1000257e:	6802      	ldr	r2, [r0, #0]
10002580:	4b25      	ldr	r3, [pc, #148]	; (10002618 <Cy_SysLib_FaultHandler+0x9c>)
10002582:	61da      	str	r2, [r3, #28]
    cy_faultFrame.r1  = faultStackAddr[CY_R1_Pos];
10002584:	6842      	ldr	r2, [r0, #4]
10002586:	621a      	str	r2, [r3, #32]
    cy_faultFrame.r2  = faultStackAddr[CY_R2_Pos];
10002588:	6882      	ldr	r2, [r0, #8]
1000258a:	625a      	str	r2, [r3, #36]	; 0x24
    cy_faultFrame.r3  = faultStackAddr[CY_R3_Pos];
1000258c:	68c2      	ldr	r2, [r0, #12]
1000258e:	629a      	str	r2, [r3, #40]	; 0x28
    cy_faultFrame.r12 = faultStackAddr[CY_R12_Pos];
10002590:	6902      	ldr	r2, [r0, #16]
10002592:	62da      	str	r2, [r3, #44]	; 0x2c
    cy_faultFrame.lr  = faultStackAddr[CY_LR_Pos];
10002594:	6942      	ldr	r2, [r0, #20]
10002596:	631a      	str	r2, [r3, #48]	; 0x30
    cy_faultFrame.pc  = faultStackAddr[CY_PC_Pos];
10002598:	6982      	ldr	r2, [r0, #24]
1000259a:	635a      	str	r2, [r3, #52]	; 0x34
    cy_faultFrame.psr = faultStackAddr[CY_PSR_Pos];
1000259c:	69c2      	ldr	r2, [r0, #28]
1000259e:	639a      	str	r2, [r3, #56]	; 0x38
    cy_faultFrame.cfsr.cfsrReg = SCB->CFSR;
100025a0:	4a1e      	ldr	r2, [pc, #120]	; (1000261c <Cy_SysLib_FaultHandler+0xa0>)
100025a2:	6a91      	ldr	r1, [r2, #40]	; 0x28
100025a4:	63d9      	str	r1, [r3, #60]	; 0x3c
    cy_faultFrame.hfsr.hfsrReg = SCB->HFSR;
100025a6:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
100025a8:	6419      	str	r1, [r3, #64]	; 0x40
    cy_faultFrame.shcsr.shcsrReg = SCB->SHCSR;
100025aa:	6a51      	ldr	r1, [r2, #36]	; 0x24
100025ac:	6459      	str	r1, [r3, #68]	; 0x44
    cy_faultFrame.mmfar = SCB->MMFAR;
100025ae:	6b51      	ldr	r1, [r2, #52]	; 0x34
100025b0:	6499      	str	r1, [r3, #72]	; 0x48
    cy_faultFrame.bfar = SCB->BFAR;
100025b2:	6b92      	ldr	r2, [r2, #56]	; 0x38
100025b4:	64da      	str	r2, [r3, #76]	; 0x4c
  return __builtin_arm_get_fpscr();
100025b6:	eef1 3a10 	vmrs	r3, fpscr
    if(0U != (__get_FPSCR() & (CY_FPSCR_IXC_Msk | CY_FPSCR_IDC_Msk)))
100025ba:	f013 0f90 	tst.w	r3, #144	; 0x90
100025be:	d027      	beq.n	10002610 <Cy_SysLib_FaultHandler+0x94>
        cy_faultFrame.s0    = faultStackAddr[CY_S0_Pos];
100025c0:	6a02      	ldr	r2, [r0, #32]
100025c2:	4b15      	ldr	r3, [pc, #84]	; (10002618 <Cy_SysLib_FaultHandler+0x9c>)
100025c4:	651a      	str	r2, [r3, #80]	; 0x50
        cy_faultFrame.s1    = faultStackAddr[CY_S1_Pos];
100025c6:	6a42      	ldr	r2, [r0, #36]	; 0x24
100025c8:	655a      	str	r2, [r3, #84]	; 0x54
        cy_faultFrame.s2    = faultStackAddr[CY_S2_Pos];
100025ca:	6a82      	ldr	r2, [r0, #40]	; 0x28
100025cc:	659a      	str	r2, [r3, #88]	; 0x58
        cy_faultFrame.s3    = faultStackAddr[CY_S3_Pos];
100025ce:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
100025d0:	65da      	str	r2, [r3, #92]	; 0x5c
        cy_faultFrame.s4    = faultStackAddr[CY_S4_Pos];
100025d2:	6b02      	ldr	r2, [r0, #48]	; 0x30
100025d4:	661a      	str	r2, [r3, #96]	; 0x60
        cy_faultFrame.s5    = faultStackAddr[CY_S5_Pos];
100025d6:	6b42      	ldr	r2, [r0, #52]	; 0x34
100025d8:	665a      	str	r2, [r3, #100]	; 0x64
        cy_faultFrame.s6    = faultStackAddr[CY_S6_Pos];
100025da:	6b82      	ldr	r2, [r0, #56]	; 0x38
100025dc:	669a      	str	r2, [r3, #104]	; 0x68
        cy_faultFrame.s7    = faultStackAddr[CY_S7_Pos];
100025de:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
100025e0:	66da      	str	r2, [r3, #108]	; 0x6c
        cy_faultFrame.s8    = faultStackAddr[CY_S8_Pos];
100025e2:	6c02      	ldr	r2, [r0, #64]	; 0x40
100025e4:	671a      	str	r2, [r3, #112]	; 0x70
        cy_faultFrame.s9    = faultStackAddr[CY_S9_Pos];
100025e6:	6c42      	ldr	r2, [r0, #68]	; 0x44
100025e8:	675a      	str	r2, [r3, #116]	; 0x74
        cy_faultFrame.s10   = faultStackAddr[CY_S10_Pos];
100025ea:	6c82      	ldr	r2, [r0, #72]	; 0x48
100025ec:	679a      	str	r2, [r3, #120]	; 0x78
        cy_faultFrame.s11   = faultStackAddr[CY_S11_Pos];
100025ee:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
100025f0:	67da      	str	r2, [r3, #124]	; 0x7c
        cy_faultFrame.s12   = faultStackAddr[CY_S12_Pos];
100025f2:	6d02      	ldr	r2, [r0, #80]	; 0x50
100025f4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        cy_faultFrame.s13   = faultStackAddr[CY_S13_Pos];
100025f8:	6d42      	ldr	r2, [r0, #84]	; 0x54
100025fa:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        cy_faultFrame.s14   = faultStackAddr[CY_S14_Pos];
100025fe:	6d82      	ldr	r2, [r0, #88]	; 0x58
10002600:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        cy_faultFrame.s15   = faultStackAddr[CY_S15_Pos];
10002604:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
10002606:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        cy_faultFrame.fpscr = faultStackAddr[CY_FPSCR_Pos];
1000260a:	6e02      	ldr	r2, [r0, #96]	; 0x60
1000260c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    Cy_SysLib_ProcessingFault();
10002610:	f7ff ffb2 	bl	10002578 <Cy_SysLib_ProcessingFault>
}
10002614:	bd08      	pop	{r3, pc}
10002616:	bf00      	nop
10002618:	08002308 	.word	0x08002308
1000261c:	e000ed00 	.word	0xe000ed00

10002620 <Cy_SysClk_PeriphSetDivider>:
cy_en_sysclk_status_t
                Cy_SysClk_PeriphSetDivider(cy_en_divider_types_t dividerType,
                                           uint32_t dividerNum, uint32_t dividerValue)
{
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    if (dividerType == CY_SYSCLK_DIV_8_BIT)
10002620:	b9a0      	cbnz	r0, 1000264c <Cy_SysClk_PeriphSetDivider+0x2c>
    {
        if ((dividerNum < PERI_DIV_8_NR) &&
10002622:	2907      	cmp	r1, #7
10002624:	d831      	bhi.n	1000268a <Cy_SysClk_PeriphSetDivider+0x6a>
10002626:	2aff      	cmp	r2, #255	; 0xff
10002628:	d831      	bhi.n	1000268e <Cy_SysClk_PeriphSetDivider+0x6e>
            (dividerValue <= (PERI_DIV_8_CTL_INT8_DIV_Msk >> PERI_DIV_8_CTL_INT8_DIV_Pos)))
        {
            CY_REG32_CLR_SET(PERI_DIV_8_CTL[dividerNum], PERI_DIV_8_CTL_INT8_DIV, dividerValue);
1000262a:	4b1c      	ldr	r3, [pc, #112]	; (1000269c <Cy_SysClk_PeriphSetDivider+0x7c>)
1000262c:	6818      	ldr	r0, [r3, #0]
1000262e:	6883      	ldr	r3, [r0, #8]
10002630:	f8b0 c078 	ldrh.w	ip, [r0, #120]	; 0x78
10002634:	449c      	add	ip, r3
10002636:	f85c 0021 	ldr.w	r0, [ip, r1, lsl #2]
1000263a:	f420 407f 	bic.w	r0, r0, #65280	; 0xff00
1000263e:	0212      	lsls	r2, r2, #8
10002640:	b292      	uxth	r2, r2
10002642:	4302      	orrs	r2, r0
10002644:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
            retVal = CY_SYSCLK_SUCCESS;
10002648:	2000      	movs	r0, #0
1000264a:	4770      	bx	lr
        }
    }
    else if (dividerType == CY_SYSCLK_DIV_16_BIT)
1000264c:	2801      	cmp	r0, #1
1000264e:	d001      	beq.n	10002654 <Cy_SysClk_PeriphSetDivider+0x34>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10002650:	4813      	ldr	r0, [pc, #76]	; (100026a0 <Cy_SysClk_PeriphSetDivider+0x80>)
10002652:	4770      	bx	lr
    {
        if ((dividerNum < PERI_DIV_16_NR) &&
10002654:	290f      	cmp	r1, #15
10002656:	d81c      	bhi.n	10002692 <Cy_SysClk_PeriphSetDivider+0x72>
10002658:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
1000265c:	d21b      	bcs.n	10002696 <Cy_SysClk_PeriphSetDivider+0x76>
            (dividerValue <= (PERI_DIV_16_CTL_INT16_DIV_Msk >> PERI_DIV_16_CTL_INT16_DIV_Pos)))
        {
            CY_REG32_CLR_SET(PERI_DIV_16_CTL[dividerNum], PERI_DIV_16_CTL_INT16_DIV, dividerValue);
1000265e:	4b0f      	ldr	r3, [pc, #60]	; (1000269c <Cy_SysClk_PeriphSetDivider+0x7c>)
10002660:	6818      	ldr	r0, [r3, #0]
10002662:	6883      	ldr	r3, [r0, #8]
10002664:	f8b0 c07a 	ldrh.w	ip, [r0, #122]	; 0x7a
10002668:	449c      	add	ip, r3
1000266a:	f85c 0021 	ldr.w	r0, [ip, r1, lsl #2]
1000266e:	f420 007f 	bic.w	r0, r0, #16711680	; 0xff0000
10002672:	f420 407f 	bic.w	r0, r0, #65280	; 0xff00
10002676:	0213      	lsls	r3, r2, #8
10002678:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
1000267c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
10002680:	4303      	orrs	r3, r0
10002682:	f84c 3021 	str.w	r3, [ip, r1, lsl #2]
            retVal = CY_SYSCLK_SUCCESS;
10002686:	2000      	movs	r0, #0
10002688:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
1000268a:	4805      	ldr	r0, [pc, #20]	; (100026a0 <Cy_SysClk_PeriphSetDivider+0x80>)
1000268c:	4770      	bx	lr
1000268e:	4804      	ldr	r0, [pc, #16]	; (100026a0 <Cy_SysClk_PeriphSetDivider+0x80>)
10002690:	4770      	bx	lr
10002692:	4803      	ldr	r0, [pc, #12]	; (100026a0 <Cy_SysClk_PeriphSetDivider+0x80>)
10002694:	4770      	bx	lr
10002696:	4802      	ldr	r0, [pc, #8]	; (100026a0 <Cy_SysClk_PeriphSetDivider+0x80>)
    }
    else
    { /* return bad parameter */
    }
    return (retVal);
}
10002698:	4770      	bx	lr
1000269a:	bf00      	nop
1000269c:	080023c0 	.word	0x080023c0
100026a0:	004a0001 	.word	0x004a0001

100026a4 <Cy_SysClk_PeriphAssignDivider>:
cy_en_sysclk_status_t
                Cy_SysClk_PeriphAssignDivider(en_clk_dst_t ipBlock,
                                              cy_en_divider_types_t dividerType, uint32_t dividerNum)
{
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    if ((CY_PERI_CLOCK_NR > (uint32_t)ipBlock) && (CY_SYSCLK_DIV_24_5_BIT >= dividerType))
100026a4:	4b1b      	ldr	r3, [pc, #108]	; (10002714 <Cy_SysClk_PeriphAssignDivider+0x70>)
100026a6:	681b      	ldr	r3, [r3, #0]
100026a8:	f893 c042 	ldrb.w	ip, [r3, #66]	; 0x42
100026ac:	4584      	cmp	ip, r0
100026ae:	d92b      	bls.n	10002708 <Cy_SysClk_PeriphAssignDivider+0x64>
100026b0:	2903      	cmp	r1, #3
100026b2:	d82b      	bhi.n	1000270c <Cy_SysClk_PeriphAssignDivider+0x68>
    {
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
100026b4:	b909      	cbnz	r1, 100026ba <Cy_SysClk_PeriphAssignDivider+0x16>
100026b6:	2a07      	cmp	r2, #7
100026b8:	d90e      	bls.n	100026d8 <Cy_SysClk_PeriphAssignDivider+0x34>
100026ba:	2901      	cmp	r1, #1
100026bc:	d005      	beq.n	100026ca <Cy_SysClk_PeriphAssignDivider+0x26>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
100026be:	2902      	cmp	r1, #2
100026c0:	d006      	beq.n	100026d0 <Cy_SysClk_PeriphAssignDivider+0x2c>
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
100026c2:	2903      	cmp	r1, #3
100026c4:	d007      	beq.n	100026d6 <Cy_SysClk_PeriphAssignDivider+0x32>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
100026c6:	4814      	ldr	r0, [pc, #80]	; (10002718 <Cy_SysClk_PeriphAssignDivider+0x74>)
100026c8:	4770      	bx	lr
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
100026ca:	2a0f      	cmp	r2, #15
100026cc:	d904      	bls.n	100026d8 <Cy_SysClk_PeriphAssignDivider+0x34>
100026ce:	e7f6      	b.n	100026be <Cy_SysClk_PeriphAssignDivider+0x1a>
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
100026d0:	2a03      	cmp	r2, #3
100026d2:	d901      	bls.n	100026d8 <Cy_SysClk_PeriphAssignDivider+0x34>
100026d4:	e7f5      	b.n	100026c2 <Cy_SysClk_PeriphAssignDivider+0x1e>
            ((dividerType == CY_SYSCLK_DIV_24_5_BIT) && (dividerNum < PERI_DIV_24_5_NR)))
100026d6:	b9da      	cbnz	r2, 10002710 <Cy_SysClk_PeriphAssignDivider+0x6c>
{
100026d8:	b500      	push	{lr}
        {
            PERI_CLOCK_CTL[ipBlock] = _VAL2FLD(CY_PERI_CLOCK_CTL_TYPE_SEL, dividerType) |
100026da:	f893 e075 	ldrb.w	lr, [r3, #117]	; 0x75
100026de:	fa01 f10e 	lsl.w	r1, r1, lr
100026e2:	f04f 0c03 	mov.w	ip, #3
100026e6:	fa0c fc0e 	lsl.w	ip, ip, lr
100026ea:	ea01 010c 	and.w	r1, r1, ip
                                      _VAL2FLD(CY_PERI_CLOCK_CTL_DIV_SEL, dividerNum);
100026ee:	f893 c074 	ldrb.w	ip, [r3, #116]	; 0x74
100026f2:	ea0c 0202 	and.w	r2, ip, r2
            PERI_CLOCK_CTL[ipBlock] = _VAL2FLD(CY_PERI_CLOCK_CTL_TYPE_SEL, dividerType) |
100026f6:	689b      	ldr	r3, [r3, #8]
100026f8:	4311      	orrs	r1, r2
100026fa:	f500 7040 	add.w	r0, r0, #768	; 0x300
100026fe:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
            retVal = CY_SYSCLK_SUCCESS;
10002702:	2000      	movs	r0, #0
        }
    }
    return (retVal);
}
10002704:	f85d fb04 	ldr.w	pc, [sp], #4
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10002708:	4803      	ldr	r0, [pc, #12]	; (10002718 <Cy_SysClk_PeriphAssignDivider+0x74>)
1000270a:	4770      	bx	lr
1000270c:	4802      	ldr	r0, [pc, #8]	; (10002718 <Cy_SysClk_PeriphAssignDivider+0x74>)
1000270e:	4770      	bx	lr
10002710:	4801      	ldr	r0, [pc, #4]	; (10002718 <Cy_SysClk_PeriphAssignDivider+0x74>)
}
10002712:	4770      	bx	lr
10002714:	080023c0 	.word	0x080023c0
10002718:	004a0001 	.word	0x004a0001

1000271c <Cy_SysClk_PeriphEnableDivider>:

cy_en_sysclk_status_t
                Cy_SysClk_PeriphEnableDivider(cy_en_divider_types_t dividerType, uint32_t dividerNum)
{
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    if (dividerType <= CY_SYSCLK_DIV_24_5_BIT)
1000271c:	2803      	cmp	r0, #3
1000271e:	d836      	bhi.n	1000278e <Cy_SysClk_PeriphEnableDivider+0x72>
    {
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
10002720:	b908      	cbnz	r0, 10002726 <Cy_SysClk_PeriphEnableDivider+0xa>
10002722:	2907      	cmp	r1, #7
10002724:	d90e      	bls.n	10002744 <Cy_SysClk_PeriphEnableDivider+0x28>
10002726:	2801      	cmp	r0, #1
10002728:	d005      	beq.n	10002736 <Cy_SysClk_PeriphEnableDivider+0x1a>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
1000272a:	2802      	cmp	r0, #2
1000272c:	d006      	beq.n	1000273c <Cy_SysClk_PeriphEnableDivider+0x20>
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
1000272e:	2803      	cmp	r0, #3
10002730:	d007      	beq.n	10002742 <Cy_SysClk_PeriphEnableDivider+0x26>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10002732:	4819      	ldr	r0, [pc, #100]	; (10002798 <Cy_SysClk_PeriphEnableDivider+0x7c>)
10002734:	4770      	bx	lr
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
10002736:	290f      	cmp	r1, #15
10002738:	d904      	bls.n	10002744 <Cy_SysClk_PeriphEnableDivider+0x28>
1000273a:	e7f6      	b.n	1000272a <Cy_SysClk_PeriphEnableDivider+0xe>
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
1000273c:	2903      	cmp	r1, #3
1000273e:	d901      	bls.n	10002744 <Cy_SysClk_PeriphEnableDivider+0x28>
10002740:	e7f5      	b.n	1000272e <Cy_SysClk_PeriphEnableDivider+0x12>
            ((dividerType == CY_SYSCLK_DIV_24_5_BIT) && (dividerNum < PERI_DIV_24_5_NR)))
10002742:	bb31      	cbnz	r1, 10002792 <Cy_SysClk_PeriphEnableDivider+0x76>
{
10002744:	b510      	push	{r4, lr}
        {
            /* specify the divider, make the reference = clk_peri, and enable the divider */
            PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk                         |
                           CY_PERI_DIV_CMD_PA_TYPE_SEL_Msk                 |
10002746:	4b15      	ldr	r3, [pc, #84]	; (1000279c <Cy_SysClk_PeriphEnableDivider+0x80>)
10002748:	681a      	ldr	r2, [r3, #0]
1000274a:	f892 3077 	ldrb.w	r3, [r2, #119]	; 0x77
1000274e:	f04f 0e03 	mov.w	lr, #3
10002752:	fa0e f303 	lsl.w	r3, lr, r3
                           CY_PERI_DIV_CMD_PA_DIV_SEL_Msk                  |
10002756:	f892 c074 	ldrb.w	ip, [r2, #116]	; 0x74
1000275a:	f892 4076 	ldrb.w	r4, [r2, #118]	; 0x76
1000275e:	fa0c f404 	lsl.w	r4, ip, r4
                           CY_PERI_DIV_CMD_PA_TYPE_SEL_Msk                 |
10002762:	4323      	orrs	r3, r4
                           _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10002764:	f892 4075 	ldrb.w	r4, [r2, #117]	; 0x75
10002768:	40a0      	lsls	r0, r4
1000276a:	fa0e fe04 	lsl.w	lr, lr, r4
1000276e:	ea00 000e 	and.w	r0, r0, lr
                           CY_PERI_DIV_CMD_PA_DIV_SEL_Msk                  |
10002772:	4318      	orrs	r0, r3
                           _VAL2FLD(CY_PERI_DIV_CMD_DIV_SEL,  dividerNum);
10002774:	ea0c 0101 	and.w	r1, ip, r1
            PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk                         |
10002778:	6893      	ldr	r3, [r2, #8]
                           _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
1000277a:	4308      	orrs	r0, r1
1000277c:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
            PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk                         |
10002780:	f8c3 0400 	str.w	r0, [r3, #1024]	; 0x400
            (void)PERI_DIV_CMD; /* dummy read to handle buffered writes */
10002784:	6893      	ldr	r3, [r2, #8]
10002786:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
            retVal = CY_SYSCLK_SUCCESS;
1000278a:	2000      	movs	r0, #0
        }
    }
    return (retVal);
}
1000278c:	bd10      	pop	{r4, pc}
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
1000278e:	4802      	ldr	r0, [pc, #8]	; (10002798 <Cy_SysClk_PeriphEnableDivider+0x7c>)
10002790:	4770      	bx	lr
10002792:	4801      	ldr	r0, [pc, #4]	; (10002798 <Cy_SysClk_PeriphEnableDivider+0x7c>)
}
10002794:	4770      	bx	lr
10002796:	bf00      	nop
10002798:	004a0001 	.word	0x004a0001
1000279c:	080023c0 	.word	0x080023c0

100027a0 <Cy_SysClk_ClkPeriGetDivider>:
}


uint8_t Cy_SysClk_ClkPeriGetDivider(void)
{
    return ((uint8_t)_FLD2VAL(CPUSS_CM0_CLOCK_CTL_PERI_INT_DIV, CPUSS_CM0_CLOCK_CTL));
100027a0:	4b03      	ldr	r3, [pc, #12]	; (100027b0 <Cy_SysClk_ClkPeriGetDivider+0x10>)
100027a2:	681b      	ldr	r3, [r3, #0]
100027a4:	681a      	ldr	r2, [r3, #0]
100027a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
100027aa:	58d0      	ldr	r0, [r2, r3]
}
100027ac:	0e00      	lsrs	r0, r0, #24
100027ae:	4770      	bx	lr
100027b0:	080023c0 	.word	0x080023c0

100027b4 <Cy_SysClk_ClkFastGetDivider>:
}


uint8_t Cy_SysClk_ClkFastGetDivider(void)
{
    return ((uint8_t)_FLD2VAL(CPUSS_CM4_CLOCK_CTL_FAST_INT_DIV, CPUSS_CM4_CLOCK_CTL));
100027b4:	4b04      	ldr	r3, [pc, #16]	; (100027c8 <Cy_SysClk_ClkFastGetDivider+0x14>)
100027b6:	681b      	ldr	r3, [r3, #0]
100027b8:	681a      	ldr	r2, [r3, #0]
100027ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
100027be:	58d0      	ldr	r0, [r2, r3]
}
100027c0:	f3c0 2007 	ubfx	r0, r0, #8, #8
100027c4:	4770      	bx	lr
100027c6:	bf00      	nop
100027c8:	080023c0 	.word	0x080023c0

100027cc <Cy_SysClk_ClkHfGetSource>:
}


cy_en_clkhf_in_sources_t Cy_SysClk_ClkHfGetSource(uint32_t clkHf)
{
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
100027cc:	4b06      	ldr	r3, [pc, #24]	; (100027e8 <Cy_SysClk_ClkHfGetSource+0x1c>)
100027ce:	681b      	ldr	r3, [r3, #0]
100027d0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
100027d4:	4283      	cmp	r3, r0
100027d6:	d800      	bhi.n	100027da <Cy_SysClk_ClkHfGetSource+0xe>
100027d8:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_in_sources_t)((uint32_t)(_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_MUX, SRSS_CLK_ROOT_SELECT[clkHf]))));
100027da:	30e0      	adds	r0, #224	; 0xe0
100027dc:	4b03      	ldr	r3, [pc, #12]	; (100027ec <Cy_SysClk_ClkHfGetSource+0x20>)
100027de:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
100027e2:	f000 000f 	and.w	r0, r0, #15
100027e6:	4770      	bx	lr
100027e8:	080023c0 	.word	0x080023c0
100027ec:	40260000 	.word	0x40260000

100027f0 <Cy_SysClk_ClkHfGetDivider>:
}


cy_en_clkhf_dividers_t Cy_SysClk_ClkHfGetDivider(uint32_t clkHf)
{
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
100027f0:	4b06      	ldr	r3, [pc, #24]	; (1000280c <Cy_SysClk_ClkHfGetDivider+0x1c>)
100027f2:	681b      	ldr	r3, [r3, #0]
100027f4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
100027f8:	4283      	cmp	r3, r0
100027fa:	d800      	bhi.n	100027fe <Cy_SysClk_ClkHfGetDivider+0xe>
100027fc:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_dividers_t)(((uint32_t)_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_DIV, SRSS_CLK_ROOT_SELECT[clkHf]))));
100027fe:	30e0      	adds	r0, #224	; 0xe0
10002800:	4b03      	ldr	r3, [pc, #12]	; (10002810 <Cy_SysClk_ClkHfGetDivider+0x20>)
10002802:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
10002806:	f3c0 1001 	ubfx	r0, r0, #4, #2
1000280a:	4770      	bx	lr
1000280c:	080023c0 	.word	0x080023c0
10002810:	40260000 	.word	0x40260000

10002814 <Cy_SysClk_WcoOkay>:
}


bool Cy_SysClk_WcoOkay(void)
{
    return (_FLD2BOOL(BACKUP_STATUS_WCO_OK, BACKUP_STATUS));
10002814:	4b02      	ldr	r3, [pc, #8]	; (10002820 <Cy_SysClk_WcoOkay+0xc>)
10002816:	6918      	ldr	r0, [r3, #16]
}
10002818:	f3c0 0080 	ubfx	r0, r0, #2, #1
1000281c:	4770      	bx	lr
1000281e:	bf00      	nop
10002820:	40270000 	.word	0x40270000

10002824 <Cy_SysClk_AltHfGetFrequency>:
    #if defined(CY_IP_MXBLESS)
        return (cy_BleEcoClockFreqHz);
    #else /* CY_IP_MXBLESS */
        return (0UL);
    #endif /* CY_IP_MXBLESS */
}
10002824:	2000      	movs	r0, #0
10002826:	4770      	bx	lr

10002828 <Cy_SysClk_AltLfGetFrequency>:


uint32_t Cy_SysClk_AltLfGetFrequency(void)
{
    return (0UL);
}
10002828:	2000      	movs	r0, #0
1000282a:	4770      	bx	lr

1000282c <Cy_SysClk_ExtClkGetFrequency>:


uint32_t Cy_SysClk_ExtClkGetFrequency(void)
{
    return (cySysClkExtFreq);
}
1000282c:	4b01      	ldr	r3, [pc, #4]	; (10002834 <Cy_SysClk_ExtClkGetFrequency+0x8>)
1000282e:	6818      	ldr	r0, [r3, #0]
10002830:	4770      	bx	lr
10002832:	bf00      	nop
10002834:	080023b8 	.word	0x080023b8

10002838 <Cy_SysClk_EcoGetStatus>:


uint32_t Cy_SysClk_EcoGetStatus(void)
{
    /* if ECO is not ready, just report the ECO_OK bit. Otherwise report 2 = ECO ready */
    return ((SRSS_CLK_ECO_STATUS_Msk == (SRSS_CLK_ECO_STATUS_Msk & SRSS_CLK_ECO_STATUS)) ?
10002838:	4b07      	ldr	r3, [pc, #28]	; (10002858 <Cy_SysClk_EcoGetStatus+0x20>)
1000283a:	f8d3 3530 	ldr.w	r3, [r3, #1328]	; 0x530
1000283e:	f003 0303 	and.w	r3, r3, #3
      CY_SYSCLK_ECOSTAT_STABLE : (SRSS_CLK_ECO_STATUS_ECO_OK_Msk & SRSS_CLK_ECO_STATUS));
10002842:	2b03      	cmp	r3, #3
10002844:	d005      	beq.n	10002852 <Cy_SysClk_EcoGetStatus+0x1a>
10002846:	4b04      	ldr	r3, [pc, #16]	; (10002858 <Cy_SysClk_EcoGetStatus+0x20>)
10002848:	f8d3 0530 	ldr.w	r0, [r3, #1328]	; 0x530
1000284c:	f000 0001 	and.w	r0, r0, #1
10002850:	4770      	bx	lr
10002852:	2002      	movs	r0, #2
}
10002854:	4770      	bx	lr
10002856:	bf00      	nop
10002858:	40260000 	.word	0x40260000

1000285c <Cy_SysClk_EcoGetFrequency>:
    return (retVal);
}


uint32_t Cy_SysClk_EcoGetFrequency(void)
{
1000285c:	b508      	push	{r3, lr}
    return ((CY_SYSCLK_ECOSTAT_STABLE == Cy_SysClk_EcoGetStatus()) ? ecoFrequency : 0UL);
1000285e:	f7ff ffeb 	bl	10002838 <Cy_SysClk_EcoGetStatus>
10002862:	2802      	cmp	r0, #2
10002864:	d001      	beq.n	1000286a <Cy_SysClk_EcoGetFrequency+0xe>
10002866:	2000      	movs	r0, #0
}
10002868:	bd08      	pop	{r3, pc}
    return ((CY_SYSCLK_ECOSTAT_STABLE == Cy_SysClk_EcoGetStatus()) ? ecoFrequency : 0UL);
1000286a:	4b01      	ldr	r3, [pc, #4]	; (10002870 <Cy_SysClk_EcoGetFrequency+0x14>)
1000286c:	6818      	ldr	r0, [r3, #0]
1000286e:	e7fb      	b.n	10002868 <Cy_SysClk_EcoGetFrequency+0xc>
10002870:	080023bc 	.word	0x080023bc

10002874 <Cy_SysClk_ClkPathGetSource>:

}


cy_en_clkpath_in_sources_t Cy_SysClk_ClkPathGetSource(uint32_t clkPath)
{
10002874:	4602      	mov	r2, r0
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10002876:	4b0c      	ldr	r3, [pc, #48]	; (100028a8 <Cy_SysClk_ClkPathGetSource+0x34>)
10002878:	681b      	ldr	r3, [r3, #0]
1000287a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
1000287e:	4283      	cmp	r3, r0
10002880:	d800      	bhi.n	10002884 <Cy_SysClk_ClkPathGetSource+0x10>
10002882:	be01      	bkpt	0x0001
    cy_en_clkpath_in_sources_t retVal =
        (cy_en_clkpath_in_sources_t )((uint32_t)_FLD2VAL(SRSS_CLK_PATH_SELECT_PATH_MUX, SRSS_CLK_PATH_SELECT[clkPath]));
10002884:	f102 03d0 	add.w	r3, r2, #208	; 0xd0
10002888:	4908      	ldr	r1, [pc, #32]	; (100028ac <Cy_SysClk_ClkPathGetSource+0x38>)
1000288a:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    cy_en_clkpath_in_sources_t retVal =
1000288e:	f000 0007 	and.w	r0, r0, #7
    if (retVal == CY_SYSCLK_CLKPATH_IN_DSIMUX)
10002892:	2804      	cmp	r0, #4
10002894:	d000      	beq.n	10002898 <Cy_SysClk_ClkPathGetSource+0x24>
    {
        retVal = (cy_en_clkpath_in_sources_t)((uint32_t)(((uint32_t)CY_SYSCLK_CLKPATH_IN_DSI) |
                    ((uint32_t)(_FLD2VAL(SRSS_CLK_DSI_SELECT_DSI_MUX, SRSS_CLK_DSI_SELECT[clkPath])))));
    }
    return (retVal);
}
10002896:	4770      	bx	lr
                    ((uint32_t)(_FLD2VAL(SRSS_CLK_DSI_SELECT_DSI_MUX, SRSS_CLK_DSI_SELECT[clkPath])))));
10002898:	32c0      	adds	r2, #192	; 0xc0
1000289a:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
1000289e:	f000 001f 	and.w	r0, r0, #31
        retVal = (cy_en_clkpath_in_sources_t)((uint32_t)(((uint32_t)CY_SYSCLK_CLKPATH_IN_DSI) |
100028a2:	f440 7080 	orr.w	r0, r0, #256	; 0x100
100028a6:	e7f6      	b.n	10002896 <Cy_SysClk_ClkPathGetSource+0x22>
100028a8:	080023c0 	.word	0x080023c0
100028ac:	40260000 	.word	0x40260000

100028b0 <Cy_SysClk_ClkPathMuxGetFrequency>:


uint32_t Cy_SysClk_ClkPathMuxGetFrequency(uint32_t clkPath)
{
100028b0:	b508      	push	{r3, lr}
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
100028b2:	4b28      	ldr	r3, [pc, #160]	; (10002954 <Cy_SysClk_ClkPathMuxGetFrequency+0xa4>)
100028b4:	681b      	ldr	r3, [r3, #0]
100028b6:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
100028ba:	4283      	cmp	r3, r0
100028bc:	d800      	bhi.n	100028c0 <Cy_SysClk_ClkPathMuxGetFrequency+0x10>
100028be:	be01      	bkpt	0x0001

    uint32_t freq = 0UL;    /* The path mux output frequency in Hz, 0 = an unknown frequency */

    /* Get the frequency of the source, i.e., the path mux input */
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
100028c0:	f7ff ffd8 	bl	10002874 <Cy_SysClk_ClkPathGetSource>
100028c4:	2803      	cmp	r0, #3
100028c6:	d90d      	bls.n	100028e4 <Cy_SysClk_ClkPathMuxGetFrequency+0x34>
100028c8:	f5b0 7f8a 	cmp.w	r0, #276	; 0x114
100028cc:	d240      	bcs.n	10002950 <Cy_SysClk_ClkPathMuxGetFrequency+0xa0>
100028ce:	f5b0 7f88 	cmp.w	r0, #272	; 0x110
100028d2:	d30f      	bcc.n	100028f4 <Cy_SysClk_ClkPathMuxGetFrequency+0x44>
100028d4:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
100028d8:	2803      	cmp	r0, #3
100028da:	d835      	bhi.n	10002948 <Cy_SysClk_ClkPathMuxGetFrequency+0x98>
100028dc:	e8df f000 	tbb	[pc, r0]
100028e0:	27311f15 	.word	0x27311f15
100028e4:	2803      	cmp	r0, #3
100028e6:	d803      	bhi.n	100028f0 <Cy_SysClk_ClkPathMuxGetFrequency+0x40>
100028e8:	e8df f000 	tbb	[pc, r0]
100028ec:	0c090630 	.word	0x0c090630
100028f0:	2000      	movs	r0, #0
100028f2:	e02c      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
100028f4:	2000      	movs	r0, #0
100028f6:	e02a      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
        case CY_SYSCLK_CLKPATH_IN_IMO: /* The IMO frequency is fixed at 8 MHz */
            freq = CY_SYSCLK_IMO_FREQ;
            break;

        case CY_SYSCLK_CLKPATH_IN_EXT:
            freq = Cy_SysClk_ExtClkGetFrequency();
100028f8:	f7ff ff98 	bl	1000282c <Cy_SysClk_ExtClkGetFrequency>
            break;
100028fc:	e027      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>

        case CY_SYSCLK_CLKPATH_IN_ECO:
            freq = Cy_SysClk_EcoGetFrequency();
100028fe:	f7ff ffad 	bl	1000285c <Cy_SysClk_EcoGetFrequency>
            break;
10002902:	e024      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>

        case CY_SYSCLK_CLKPATH_IN_ALTHF:
            freq = Cy_SysClk_AltHfGetFrequency();
10002904:	f7ff ff8e 	bl	10002824 <Cy_SysClk_AltHfGetFrequency>
            break;
10002908:	e021      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>

        case CY_SYSCLK_CLKPATH_IN_ILO:
            freq = (0UL != (SRSS_CLK_ILO_CONFIG & SRSS_CLK_ILO_CONFIG_ENABLE_Msk)) ? CY_SYSCLK_ILO_FREQ : 0UL;
1000290a:	4b13      	ldr	r3, [pc, #76]	; (10002958 <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>)
1000290c:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c
10002910:	2b00      	cmp	r3, #0
10002912:	db01      	blt.n	10002918 <Cy_SysClk_ClkPathMuxGetFrequency+0x68>
10002914:	2000      	movs	r0, #0
10002916:	e01a      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
10002918:	f44f 4000 	mov.w	r0, #32768	; 0x8000
1000291c:	e017      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            break;

        case CY_SYSCLK_CLKPATH_IN_WCO:
            freq = (Cy_SysClk_WcoOkay()) ? CY_SYSCLK_WCO_FREQ : 0UL;
1000291e:	f7ff ff79 	bl	10002814 <Cy_SysClk_WcoOkay>
10002922:	b908      	cbnz	r0, 10002928 <Cy_SysClk_ClkPathMuxGetFrequency+0x78>
10002924:	2000      	movs	r0, #0
10002926:	e012      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
10002928:	f44f 4000 	mov.w	r0, #32768	; 0x8000
1000292c:	e00f      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            break;

        case CY_SYSCLK_CLKPATH_IN_PILO:
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
1000292e:	4b0a      	ldr	r3, [pc, #40]	; (10002958 <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>)
10002930:	f8d3 353c 	ldr.w	r3, [r3, #1340]	; 0x53c
10002934:	2b00      	cmp	r3, #0
10002936:	db01      	blt.n	1000293c <Cy_SysClk_ClkPathMuxGetFrequency+0x8c>
10002938:	2000      	movs	r0, #0
        default:
            /* Don't know the frequency of dsi_out, leave freq = 0UL */
            break;
    }

    return (freq);
1000293a:	e008      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
1000293c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
10002940:	e005      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            freq = Cy_SysClk_AltLfGetFrequency();
10002942:	f7ff ff71 	bl	10002828 <Cy_SysClk_AltLfGetFrequency>
            break;
10002946:	e002      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
10002948:	2000      	movs	r0, #0
1000294a:	e000      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            freq = CY_SYSCLK_IMO_FREQ;
1000294c:	4803      	ldr	r0, [pc, #12]	; (1000295c <Cy_SysClk_ClkPathMuxGetFrequency+0xac>)
}
1000294e:	bd08      	pop	{r3, pc}
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
10002950:	2000      	movs	r0, #0
10002952:	e7fc      	b.n	1000294e <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
10002954:	080023c0 	.word	0x080023c0
10002958:	40260000 	.word	0x40260000
1000295c:	007a1200 	.word	0x007a1200

10002960 <Cy_SysClk_FllIsEnabled>:
#define MARGIN_SCALE            (100000ULL) /* 10 ^ 5 */
/** \endcond */

bool Cy_SysClk_FllIsEnabled(void)
{
    return (_FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_ENABLE, SRSS_CLK_FLL_CONFIG));
10002960:	4b02      	ldr	r3, [pc, #8]	; (1000296c <Cy_SysClk_FllIsEnabled+0xc>)
10002962:	f8d3 0580 	ldr.w	r0, [r3, #1408]	; 0x580
}
10002966:	0fc0      	lsrs	r0, r0, #31
10002968:	4770      	bx	lr
1000296a:	bf00      	nop
1000296c:	40260000 	.word	0x40260000

10002970 <Cy_SysClk_FllGetConfiguration>:
}


void Cy_SysClk_FllGetConfiguration(cy_stc_fll_manual_config_t *config)
{
    CY_ASSERT_L1(config != NULL);
10002970:	4603      	mov	r3, r0
10002972:	b338      	cbz	r0, 100029c4 <Cy_SysClk_FllGetConfiguration+0x54>
    /* read 2 parameters from CLK_FLL_CONFIG register */
    uint32_t tempReg = SRSS_CLK_FLL_CONFIG;
10002974:	4914      	ldr	r1, [pc, #80]	; (100029c8 <Cy_SysClk_FllGetConfiguration+0x58>)
10002976:	f8d1 2580 	ldr.w	r2, [r1, #1408]	; 0x580
    config->fllMult         = _FLD2VAL(SRSS_CLK_FLL_CONFIG_FLL_MULT, tempReg);
1000297a:	f3c2 0011 	ubfx	r0, r2, #0, #18
1000297e:	6018      	str	r0, [r3, #0]
    config->enableOutputDiv = _FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_OUTPUT_DIV, tempReg);
10002980:	f3c2 6200 	ubfx	r2, r2, #24, #1
10002984:	71da      	strb	r2, [r3, #7]
    /* read 2 parameters from CLK_FLL_CONFIG2 register */
    tempReg = SRSS_CLK_FLL_CONFIG2;
10002986:	f8d1 2584 	ldr.w	r2, [r1, #1412]	; 0x584
    config->refDiv          = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV, tempReg);
1000298a:	f3c2 000c 	ubfx	r0, r2, #0, #13
1000298e:	8098      	strh	r0, [r3, #4]
    config->lockTolerance   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_LOCK_TOL, tempReg);
10002990:	f3c2 4208 	ubfx	r2, r2, #16, #9
10002994:	811a      	strh	r2, [r3, #8]
    /* read 4 parameters from CLK_FLL_CONFIG3 register */
    tempReg = SRSS_CLK_FLL_CONFIG3;
10002996:	f8d1 2588 	ldr.w	r2, [r1, #1416]	; 0x588
    config->igain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN, tempReg);
1000299a:	f002 000f 	and.w	r0, r2, #15
1000299e:	7298      	strb	r0, [r3, #10]
    config->pgain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, tempReg);
100029a0:	f3c2 1003 	ubfx	r0, r2, #4, #4
100029a4:	72d8      	strb	r0, [r3, #11]
    config->settlingCount   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, tempReg);
100029a6:	f3c2 200c 	ubfx	r0, r2, #8, #13
100029aa:	8198      	strh	r0, [r3, #12]
    config->outputMode      = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, tempReg));
100029ac:	f3c2 7201 	ubfx	r2, r2, #28, #2
100029b0:	739a      	strb	r2, [r3, #14]
    /* read 2 parameters from CLK_FLL_CONFIG4 register */
    tempReg = SRSS_CLK_FLL_CONFIG4;
100029b2:	f8d1 258c 	ldr.w	r2, [r1, #1420]	; 0x58c
    config->ccoRange        = (cy_en_fll_cco_ranges_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_RANGE, tempReg));
100029b6:	f3c2 2102 	ubfx	r1, r2, #8, #3
100029ba:	7199      	strb	r1, [r3, #6]
    config->cco_Freq        = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_FREQ, tempReg);
100029bc:	f3c2 4208 	ubfx	r2, r2, #16, #9
100029c0:	821a      	strh	r2, [r3, #16]
}
100029c2:	4770      	bx	lr
100029c4:	be01      	bkpt	0x0001
}
100029c6:	e7d5      	b.n	10002974 <Cy_SysClk_FllGetConfiguration+0x4>
100029c8:	40260000 	.word	0x40260000

100029cc <Cy_SysClk_PllIsEnabled>:
#define CY_SYSCLK_PLL_MAX_OUT_FREQ (150000000UL)


bool Cy_SysClk_PllIsEnabled(uint32_t clkPath)
{
    clkPath--; /* to correctly access PLL config and status registers structures */
100029cc:	3801      	subs	r0, #1
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_PLL);
100029ce:	4b07      	ldr	r3, [pc, #28]	; (100029ec <Cy_SysClk_PllIsEnabled+0x20>)
100029d0:	681b      	ldr	r3, [r3, #0]
100029d2:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
100029d6:	4283      	cmp	r3, r0
100029d8:	d800      	bhi.n	100029dc <Cy_SysClk_PllIsEnabled+0x10>
    __asm("    bkpt    1");
100029da:	be01      	bkpt	0x0001
    return (_FLD2BOOL(SRSS_CLK_PLL_CONFIG_ENABLE, SRSS_CLK_PLL_CONFIG[clkPath]));
100029dc:	f500 70c0 	add.w	r0, r0, #384	; 0x180
100029e0:	4b03      	ldr	r3, [pc, #12]	; (100029f0 <Cy_SysClk_PllIsEnabled+0x24>)
100029e2:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
100029e6:	0fc0      	lsrs	r0, r0, #31
100029e8:	4770      	bx	lr
100029ea:	bf00      	nop
100029ec:	080023c0 	.word	0x080023c0
100029f0:	40260000 	.word	0x40260000

100029f4 <Cy_SysClk_PllGetConfiguration>:


cy_en_sysclk_status_t Cy_SysClk_PllGetConfiguration(uint32_t clkPath, cy_stc_pll_manual_config_t *config)
{
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    clkPath--; /* to correctly access PLL config and status register structures */
100029f4:	3801      	subs	r0, #1
    if (clkPath < CY_SRSS_NUM_PLL)
100029f6:	4b0f      	ldr	r3, [pc, #60]	; (10002a34 <Cy_SysClk_PllGetConfiguration+0x40>)
100029f8:	681b      	ldr	r3, [r3, #0]
100029fa:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
100029fe:	4283      	cmp	r3, r0
10002a00:	d915      	bls.n	10002a2e <Cy_SysClk_PllGetConfiguration+0x3a>
    {
        uint32_t tempReg = SRSS_CLK_PLL_CONFIG[clkPath];
10002a02:	f500 70c0 	add.w	r0, r0, #384	; 0x180
10002a06:	4b0c      	ldr	r3, [pc, #48]	; (10002a38 <Cy_SysClk_PllGetConfiguration+0x44>)
10002a08:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
        config->feedbackDiv  = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_FEEDBACK_DIV,  tempReg);
10002a0c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
10002a10:	700a      	strb	r2, [r1, #0]
        config->referenceDiv = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_REFERENCE_DIV, tempReg);
10002a12:	f3c3 2204 	ubfx	r2, r3, #8, #5
10002a16:	704a      	strb	r2, [r1, #1]
        config->outputDiv    = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_OUTPUT_DIV,    tempReg);
10002a18:	f3c3 4204 	ubfx	r2, r3, #16, #5
10002a1c:	708a      	strb	r2, [r1, #2]
        config->lfMode       =         _FLD2BOOL(SRSS_CLK_PLL_CONFIG_PLL_LF_MODE,   tempReg);
10002a1e:	f3c3 62c0 	ubfx	r2, r3, #27, #1
10002a22:	70ca      	strb	r2, [r1, #3]
        config->outputMode   = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_BYPASS_SEL, tempReg));
10002a24:	f3c3 7301 	ubfx	r3, r3, #28, #2
10002a28:	710b      	strb	r3, [r1, #4]
        retVal = CY_SYSCLK_SUCCESS;
10002a2a:	2000      	movs	r0, #0
10002a2c:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10002a2e:	4803      	ldr	r0, [pc, #12]	; (10002a3c <Cy_SysClk_PllGetConfiguration+0x48>)
    }
    return (retVal);
}
10002a30:	4770      	bx	lr
10002a32:	bf00      	nop
10002a34:	080023c0 	.word	0x080023c0
10002a38:	40260000 	.word	0x40260000
10002a3c:	004a0001 	.word	0x004a0001

10002a40 <Cy_SysClk_FllGetFrequency>:
    return (CY_SYSLIB_DIV_ROUND(freq, 1UL + (uint32_t)Cy_SysClk_ClkTimerGetDivider()));
}


uint32_t Cy_SysClk_FllGetFrequency(void)
{
10002a40:	b570      	push	{r4, r5, r6, lr}
10002a42:	b086      	sub	sp, #24
    uint32_t rDiv;    /* FLL reference divider */
    uint32_t oDiv;    /* FLL output divider */
    bool  enabled;    /* FLL enable status; n/a for direct */
    uint32_t freq = 0UL;    /* FLL Frequency */

    cy_stc_fll_manual_config_t fllCfg = {0UL,0U,CY_SYSCLK_FLL_CCO_RANGE0,false,0U,0U,0U,0U,CY_SYSCLK_FLLPLL_OUTPUT_AUTO,0U};
10002a44:	2300      	movs	r3, #0
10002a46:	9301      	str	r3, [sp, #4]
10002a48:	9302      	str	r3, [sp, #8]
10002a4a:	9303      	str	r3, [sp, #12]
10002a4c:	9304      	str	r3, [sp, #16]
10002a4e:	9305      	str	r3, [sp, #20]
    Cy_SysClk_FllGetConfiguration(&fllCfg);
10002a50:	a801      	add	r0, sp, #4
10002a52:	f7ff ff8d 	bl	10002970 <Cy_SysClk_FllGetConfiguration>
    enabled = (Cy_SysClk_FllIsEnabled()) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != fllCfg.outputMode);
10002a56:	f7ff ff83 	bl	10002960 <Cy_SysClk_FllIsEnabled>
10002a5a:	b138      	cbz	r0, 10002a6c <Cy_SysClk_FllGetFrequency+0x2c>
10002a5c:	f89d 3012 	ldrb.w	r3, [sp, #18]
10002a60:	2b02      	cmp	r3, #2
10002a62:	d001      	beq.n	10002a68 <Cy_SysClk_FllGetFrequency+0x28>
10002a64:	2101      	movs	r1, #1
10002a66:	e002      	b.n	10002a6e <Cy_SysClk_FllGetFrequency+0x2e>
10002a68:	2100      	movs	r1, #0
10002a6a:	e000      	b.n	10002a6e <Cy_SysClk_FllGetFrequency+0x2e>
10002a6c:	2100      	movs	r1, #0
    fDiv = fllCfg.fllMult;
10002a6e:	9d01      	ldr	r5, [sp, #4]
    rDiv = fllCfg.refDiv;
10002a70:	f8bd 4008 	ldrh.w	r4, [sp, #8]
10002a74:	4620      	mov	r0, r4
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;
10002a76:	f89d 300b 	ldrb.w	r3, [sp, #11]
10002a7a:	b183      	cbz	r3, 10002a9e <Cy_SysClk_FllGetFrequency+0x5e>
10002a7c:	2602      	movs	r6, #2

    if (enabled && /* If FLL is enabled and not bypassed */
10002a7e:	b181      	cbz	r1, 10002aa2 <Cy_SysClk_FllGetFrequency+0x62>
10002a80:	b184      	cbz	r4, 10002aa4 <Cy_SysClk_FllGetFrequency+0x64>
        (0UL != rDiv)) /* to avoid division by zero */
    {
        freq = Cy_SysClk_ClkPathMuxGetFrequency(0UL); /* FLL mapped always to path 0 */
10002a82:	2000      	movs	r0, #0
10002a84:	f7ff ff14 	bl	100028b0 <Cy_SysClk_ClkPathMuxGetFrequency>
        freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
10002a88:	fba0 0105 	umull	r0, r1, r0, r5
10002a8c:	fba4 2306 	umull	r2, r3, r4, r6
10002a90:	0854      	lsrs	r4, r2, #1
10002a92:	1900      	adds	r0, r0, r4
10002a94:	f141 0100 	adc.w	r1, r1, #0
10002a98:	f000 fa9c 	bl	10002fd4 <__aeabi_uldivmod>
10002a9c:	e002      	b.n	10002aa4 <Cy_SysClk_FllGetFrequency+0x64>
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;
10002a9e:	2601      	movs	r6, #1
10002aa0:	e7ed      	b.n	10002a7e <Cy_SysClk_FllGetFrequency+0x3e>
    uint32_t freq = 0UL;    /* FLL Frequency */
10002aa2:	2000      	movs	r0, #0
                                             ((uint64_t)rDiv * (uint64_t)oDiv));
    }

    return (freq);
}
10002aa4:	b006      	add	sp, #24
10002aa6:	bd70      	pop	{r4, r5, r6, pc}

10002aa8 <Cy_SysClk_PllGetFrequency>:
    uint32_t rDiv;    /* PLL reference divider */
    uint32_t oDiv;    /* PLL output divider */
    bool  enabled;    /* PLL enable status; n/a for direct */
    uint32_t freq=0UL;    /* PLL Frequency */

    if((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
10002aa8:	4b25      	ldr	r3, [pc, #148]	; (10002b40 <Cy_SysClk_PllGetFrequency+0x98>)
10002aaa:	681b      	ldr	r3, [r3, #0]
10002aac:	f893 203f 	ldrb.w	r2, [r3, #63]	; 0x3f
10002ab0:	2a00      	cmp	r2, #0
10002ab2:	d043      	beq.n	10002b3c <Cy_SysClk_PllGetFrequency+0x94>
{
10002ab4:	b5f0      	push	{r4, r5, r6, r7, lr}
10002ab6:	b083      	sub	sp, #12
10002ab8:	4604      	mov	r4, r0
    if((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
10002aba:	b158      	cbz	r0, 10002ad4 <Cy_SysClk_PllGetFrequency+0x2c>
    {
        CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10002abc:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
10002ac0:	4283      	cmp	r3, r0
10002ac2:	d800      	bhi.n	10002ac6 <Cy_SysClk_PllGetFrequency+0x1e>
10002ac4:	be01      	bkpt	0x0001

        if (clkPath <= CY_SRSS_NUM_PLL)
10002ac6:	4b1e      	ldr	r3, [pc, #120]	; (10002b40 <Cy_SysClk_PllGetFrequency+0x98>)
10002ac8:	681b      	ldr	r3, [r3, #0]
10002aca:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
10002ace:	42a3      	cmp	r3, r4
10002ad0:	d202      	bcs.n	10002ad8 <Cy_SysClk_PllGetFrequency+0x30>
    uint32_t freq=0UL;    /* PLL Frequency */
10002ad2:	2000      	movs	r0, #0
            }
        }
    }

    return (freq);
}
10002ad4:	b003      	add	sp, #12
10002ad6:	bdf0      	pop	{r4, r5, r6, r7, pc}
            cy_stc_pll_manual_config_t pllcfg = {0U,0U,0U,false,CY_SYSCLK_FLLPLL_OUTPUT_AUTO};
10002ad8:	2300      	movs	r3, #0
10002ada:	9300      	str	r3, [sp, #0]
10002adc:	f88d 3004 	strb.w	r3, [sp, #4]
            (void)Cy_SysClk_PllGetConfiguration(clkPath, &pllcfg);
10002ae0:	4669      	mov	r1, sp
10002ae2:	4620      	mov	r0, r4
10002ae4:	f7ff ff86 	bl	100029f4 <Cy_SysClk_PllGetConfiguration>
            enabled = (Cy_SysClk_PllIsEnabled(clkPath)) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != pllcfg.outputMode);
10002ae8:	4620      	mov	r0, r4
10002aea:	f7ff ff6f 	bl	100029cc <Cy_SysClk_PllIsEnabled>
10002aee:	b138      	cbz	r0, 10002b00 <Cy_SysClk_PllGetFrequency+0x58>
10002af0:	f89d 3004 	ldrb.w	r3, [sp, #4]
10002af4:	2b02      	cmp	r3, #2
10002af6:	d001      	beq.n	10002afc <Cy_SysClk_PllGetFrequency+0x54>
10002af8:	2301      	movs	r3, #1
10002afa:	e002      	b.n	10002b02 <Cy_SysClk_PllGetFrequency+0x5a>
10002afc:	2300      	movs	r3, #0
10002afe:	e000      	b.n	10002b02 <Cy_SysClk_PllGetFrequency+0x5a>
10002b00:	2300      	movs	r3, #0
            fDiv = pllcfg.feedbackDiv;
10002b02:	f89d 7000 	ldrb.w	r7, [sp]
            rDiv = pllcfg.referenceDiv;
10002b06:	f89d 5001 	ldrb.w	r5, [sp, #1]
10002b0a:	4628      	mov	r0, r5
            oDiv = pllcfg.outputDiv;
10002b0c:	f89d 6002 	ldrb.w	r6, [sp, #2]
            if (enabled && /* If PLL is enabled and not bypassed */
10002b10:	b193      	cbz	r3, 10002b38 <Cy_SysClk_PllGetFrequency+0x90>
10002b12:	2d00      	cmp	r5, #0
10002b14:	d0de      	beq.n	10002ad4 <Cy_SysClk_PllGetFrequency+0x2c>
            (0UL != rDiv) && (0UL != oDiv)) /* to avoid division by zero */
10002b16:	b90e      	cbnz	r6, 10002b1c <Cy_SysClk_PllGetFrequency+0x74>
    uint32_t freq=0UL;    /* PLL Frequency */
10002b18:	4630      	mov	r0, r6
10002b1a:	e7db      	b.n	10002ad4 <Cy_SysClk_PllGetFrequency+0x2c>
                freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
10002b1c:	4620      	mov	r0, r4
10002b1e:	f7ff fec7 	bl	100028b0 <Cy_SysClk_ClkPathMuxGetFrequency>
                freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
10002b22:	fba0 7107 	umull	r7, r1, r0, r7
10002b26:	fba5 2306 	umull	r2, r3, r5, r6
10002b2a:	0850      	lsrs	r0, r2, #1
10002b2c:	1838      	adds	r0, r7, r0
10002b2e:	f141 0100 	adc.w	r1, r1, #0
10002b32:	f000 fa4f 	bl	10002fd4 <__aeabi_uldivmod>
10002b36:	e7cd      	b.n	10002ad4 <Cy_SysClk_PllGetFrequency+0x2c>
    uint32_t freq=0UL;    /* PLL Frequency */
10002b38:	2000      	movs	r0, #0
10002b3a:	e7cb      	b.n	10002ad4 <Cy_SysClk_PllGetFrequency+0x2c>
10002b3c:	2000      	movs	r0, #0
}
10002b3e:	4770      	bx	lr
10002b40:	080023c0 	.word	0x080023c0

10002b44 <Cy_SysClk_ClkPathGetFrequency>:
{
10002b44:	b510      	push	{r4, lr}
10002b46:	4604      	mov	r4, r0
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10002b48:	4b0d      	ldr	r3, [pc, #52]	; (10002b80 <Cy_SysClk_ClkPathGetFrequency+0x3c>)
10002b4a:	681b      	ldr	r3, [r3, #0]
10002b4c:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
10002b50:	4283      	cmp	r3, r0
10002b52:	d800      	bhi.n	10002b56 <Cy_SysClk_ClkPathGetFrequency+0x12>
10002b54:	be01      	bkpt	0x0001
    if (clkPath == (uint32_t)CY_SYSCLK_CLKHF_IN_CLKPATH0) /* FLL? (always path 0) */
10002b56:	b14c      	cbz	r4, 10002b6c <Cy_SysClk_ClkPathGetFrequency+0x28>
    else if (clkPath <= CY_SRSS_NUM_PLL) /* PLL? (always path 1...N)*/
10002b58:	4b09      	ldr	r3, [pc, #36]	; (10002b80 <Cy_SysClk_ClkPathGetFrequency+0x3c>)
10002b5a:	681b      	ldr	r3, [r3, #0]
10002b5c:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
10002b60:	42a3      	cmp	r3, r4
10002b62:	d208      	bcs.n	10002b76 <Cy_SysClk_ClkPathGetFrequency+0x32>
        freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
10002b64:	4620      	mov	r0, r4
10002b66:	f7ff fea3 	bl	100028b0 <Cy_SysClk_ClkPathMuxGetFrequency>
}
10002b6a:	bd10      	pop	{r4, pc}
        freq = Cy_SysClk_FllGetFrequency();
10002b6c:	f7ff ff68 	bl	10002a40 <Cy_SysClk_FllGetFrequency>
    if(freq==0UL)
10002b70:	2800      	cmp	r0, #0
10002b72:	d1fa      	bne.n	10002b6a <Cy_SysClk_ClkPathGetFrequency+0x26>
10002b74:	e7f6      	b.n	10002b64 <Cy_SysClk_ClkPathGetFrequency+0x20>
        freq = Cy_SysClk_PllGetFrequency(clkPath);
10002b76:	4620      	mov	r0, r4
10002b78:	f7ff ff96 	bl	10002aa8 <Cy_SysClk_PllGetFrequency>
10002b7c:	e7f8      	b.n	10002b70 <Cy_SysClk_ClkPathGetFrequency+0x2c>
10002b7e:	bf00      	nop
10002b80:	080023c0 	.word	0x080023c0

10002b84 <Cy_SysClk_ClkHfGetFrequency>:
{
10002b84:	b570      	push	{r4, r5, r6, lr}
10002b86:	4606      	mov	r6, r0
    uint32_t pDiv = 1UL << (uint32_t)Cy_SysClk_ClkHfGetDivider(clkHf); /* root prescaler (1/2/4/8) */
10002b88:	f7ff fe32 	bl	100027f0 <Cy_SysClk_ClkHfGetDivider>
10002b8c:	4604      	mov	r4, r0
10002b8e:	2501      	movs	r5, #1
10002b90:	4085      	lsls	r5, r0
    uint32_t path = (uint32_t) Cy_SysClk_ClkHfGetSource(clkHf); /* path input for root 0 (clkHf[0]) */
10002b92:	4630      	mov	r0, r6
10002b94:	f7ff fe1a 	bl	100027cc <Cy_SysClk_ClkHfGetSource>
    uint32_t freq = Cy_SysClk_ClkPathGetFrequency(path);
10002b98:	f7ff ffd4 	bl	10002b44 <Cy_SysClk_ClkPathGetFrequency>
    return (CY_SYSLIB_DIV_ROUND(freq, pDiv));
10002b9c:	eb00 0055 	add.w	r0, r0, r5, lsr #1
}
10002ba0:	40e0      	lsrs	r0, r4
10002ba2:	bd70      	pop	{r4, r5, r6, pc}

10002ba4 <Cy_PDL_Init>:
* This function must be called prior calling any function in PDL.
*
*******************************************************************************/
void Cy_PDL_Init(const cy_stc_device_t * device)
{
    cy_device = device;
10002ba4:	4b01      	ldr	r3, [pc, #4]	; (10002bac <Cy_PDL_Init+0x8>)
10002ba6:	6018      	str	r0, [r3, #0]
}
10002ba8:	4770      	bx	lr
10002baa:	bf00      	nop
10002bac:	080023c0 	.word	0x080023c0

10002bb0 <Cy_SCB_Write>:
__STATIC_INLINE uint32_t Cy_SCB_GetFifoSize(CySCB_Type const *base)
{
#if(CY_IP_MXSCB_VERSION>=2)
    {return (((uint32_t)(CY_SCB_FIFO_SIZE)) >> _FLD2VAL(SCB_CTRL_MEM_WIDTH, SCB_CTRL(base)));}
#elif(CY_IP_MXSCB_VERSION==1)
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
10002bb0:	6803      	ldr	r3, [r0, #0]
10002bb2:	f413 6f00 	tst.w	r3, #2048	; 0x800
10002bb6:	d00a      	beq.n	10002bce <Cy_SCB_Write+0x1e>
10002bb8:	2280      	movs	r2, #128	; 0x80
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
10002bba:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
10002bbe:	f3c3 0308 	ubfx	r3, r3, #0, #9
*******************************************************************************/
uint32_t Cy_SCB_Write(CySCB_Type *base, uint32_t data)
{
    uint32_t numCopied = 0UL;

    if (Cy_SCB_GetFifoSize(base) != Cy_SCB_GetNumInTxFifo(base))
10002bc2:	4293      	cmp	r3, r2
10002bc4:	d005      	beq.n	10002bd2 <Cy_SCB_Write+0x22>
    SCB_TX_FIFO_WR(base) = data;
10002bc6:	f8c0 1240 	str.w	r1, [r0, #576]	; 0x240
    {
        Cy_SCB_WriteTxFifo(base, data);

        numCopied = 1UL;
10002bca:	2001      	movs	r0, #1
10002bcc:	4770      	bx	lr
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
10002bce:	2240      	movs	r2, #64	; 0x40
10002bd0:	e7f3      	b.n	10002bba <Cy_SCB_Write+0xa>
    uint32_t numCopied = 0UL;
10002bd2:	2000      	movs	r0, #0
    }

    return (numCopied);
}
10002bd4:	4770      	bx	lr

10002bd6 <Cy_SCB_WriteString>:
* \param string
* The pointer to the null terminated string array.
*
*******************************************************************************/
void Cy_SCB_WriteString(CySCB_Type *base, char_t const string[])
{
10002bd6:	b500      	push	{lr}
10002bd8:	468e      	mov	lr, r1
10002bda:	6803      	ldr	r3, [r0, #0]
10002bdc:	f413 6f00 	tst.w	r3, #2048	; 0x800
10002be0:	d003      	beq.n	10002bea <Cy_SCB_WriteString+0x14>
10002be2:	2280      	movs	r2, #128	; 0x80
    uint32_t idx = 0UL;
10002be4:	f04f 0c00 	mov.w	ip, #0
    uint32_t fifoSize = Cy_SCB_GetFifoSize(base);

    /* Put data from TX FIFO. Stop when string is terminated */
    while (((char_t) 0) != string[idx])
10002be8:	e00b      	b.n	10002c02 <Cy_SCB_WriteString+0x2c>
10002bea:	2240      	movs	r2, #64	; 0x40
10002bec:	e7fa      	b.n	10002be4 <Cy_SCB_WriteString+0xe>
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
10002bee:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
10002bf2:	f3c3 0308 	ubfx	r3, r3, #0, #9
    {
        /* Wait for free space to be available */
        while (fifoSize == Cy_SCB_GetNumInTxFifo(base))
10002bf6:	429a      	cmp	r2, r3
10002bf8:	d0f9      	beq.n	10002bee <Cy_SCB_WriteString+0x18>
    SCB_TX_FIFO_WR(base) = data;
10002bfa:	f8c0 1240 	str.w	r1, [r0, #576]	; 0x240
        {
        }

        Cy_SCB_WriteTxFifo(base, (uint32_t) string[idx]);
        ++idx;
10002bfe:	f10c 0c01 	add.w	ip, ip, #1
    while (((char_t) 0) != string[idx])
10002c02:	f81e 100c 	ldrb.w	r1, [lr, ip]
10002c06:	2900      	cmp	r1, #0
10002c08:	d1f1      	bne.n	10002bee <Cy_SCB_WriteString+0x18>
    }
}
10002c0a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

10002c10 <Cy_SCB_UART_Init>:
* Ensure that the SCB block is disabled before calling this function.
*
*******************************************************************************/
cy_en_scb_uart_status_t Cy_SCB_UART_Init(CySCB_Type *base, cy_stc_scb_uart_config_t const *config, cy_stc_scb_uart_context_t *context)
{
    if ((NULL == base) || (NULL == config))
10002c10:	2800      	cmp	r0, #0
10002c12:	f000 817f 	beq.w	10002f14 <Cy_SCB_UART_Init+0x304>
10002c16:	4603      	mov	r3, r0
10002c18:	2900      	cmp	r1, #0
10002c1a:	f000 817d 	beq.w	10002f18 <Cy_SCB_UART_Init+0x308>
{
10002c1e:	b410      	push	{r4}
    {
        return CY_SCB_UART_BAD_PARAM;
    }

    CY_ASSERT_L3(CY_SCB_UART_IS_MODE_VALID     (config->uartMode));
10002c20:	7808      	ldrb	r0, [r1, #0]
10002c22:	2802      	cmp	r0, #2
10002c24:	d900      	bls.n	10002c28 <Cy_SCB_UART_Init+0x18>
10002c26:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_STOP_BITS_VALID(config->stopBits));
10002c28:	7b48      	ldrb	r0, [r1, #13]
10002c2a:	3802      	subs	r0, #2
10002c2c:	b2c0      	uxtb	r0, r0
10002c2e:	2806      	cmp	r0, #6
10002c30:	d900      	bls.n	10002c34 <Cy_SCB_UART_Init+0x24>
10002c32:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_PARITY_VALID   (config->parity));
10002c34:	7b88      	ldrb	r0, [r1, #14]
10002c36:	b120      	cbz	r0, 10002c42 <Cy_SCB_UART_Init+0x32>
10002c38:	2802      	cmp	r0, #2
10002c3a:	d002      	beq.n	10002c42 <Cy_SCB_UART_Init+0x32>
10002c3c:	2803      	cmp	r0, #3
10002c3e:	d000      	beq.n	10002c42 <Cy_SCB_UART_Init+0x32>
10002c40:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_POLARITY_VALID (config->ctsPolarity));
10002c42:	f891 0021 	ldrb.w	r0, [r1, #33]	; 0x21
10002c46:	2801      	cmp	r0, #1
10002c48:	d900      	bls.n	10002c4c <Cy_SCB_UART_Init+0x3c>
10002c4a:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_POLARITY_VALID (config->rtsPolarity));
10002c4c:	f891 0028 	ldrb.w	r0, [r1, #40]	; 0x28
10002c50:	2801      	cmp	r0, #1
10002c52:	d900      	bls.n	10002c56 <Cy_SCB_UART_Init+0x46>
10002c54:	be01      	bkpt	0x0001

    CY_ASSERT_L2(CY_SCB_UART_IS_OVERSAMPLE_VALID  (config->oversample, config->uartMode, config->irdaEnableLowPowerReceiver));
10002c56:	7808      	ldrb	r0, [r1, #0]
10002c58:	2801      	cmp	r0, #1
10002c5a:	d906      	bls.n	10002c6a <Cy_SCB_UART_Init+0x5a>
10002c5c:	7f88      	ldrb	r0, [r1, #30]
10002c5e:	b148      	cbz	r0, 10002c74 <Cy_SCB_UART_Init+0x64>
10002c60:	6848      	ldr	r0, [r1, #4]
10002c62:	3801      	subs	r0, #1
10002c64:	2806      	cmp	r0, #6
10002c66:	d905      	bls.n	10002c74 <Cy_SCB_UART_Init+0x64>
10002c68:	e003      	b.n	10002c72 <Cy_SCB_UART_Init+0x62>
10002c6a:	6848      	ldr	r0, [r1, #4]
10002c6c:	3808      	subs	r0, #8
10002c6e:	2808      	cmp	r0, #8
10002c70:	d900      	bls.n	10002c74 <Cy_SCB_UART_Init+0x64>
10002c72:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_UART_IS_DATA_WIDTH_VALID  (config->dataWidth));
10002c74:	6888      	ldr	r0, [r1, #8]
10002c76:	3805      	subs	r0, #5
10002c78:	2804      	cmp	r0, #4
10002c7a:	d900      	bls.n	10002c7e <Cy_SCB_UART_Init+0x6e>
10002c7c:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_UART_IS_ADDRESS_VALID     (config->receiverAddress));
10002c7e:	6948      	ldr	r0, [r1, #20]
10002c80:	28ff      	cmp	r0, #255	; 0xff
10002c82:	d900      	bls.n	10002c86 <Cy_SCB_UART_Init+0x76>
10002c84:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_UART_IS_ADDRESS_MASK_VALID(config->receiverAddressMask));
10002c86:	6988      	ldr	r0, [r1, #24]
10002c88:	28ff      	cmp	r0, #255	; 0xff
10002c8a:	d900      	bls.n	10002c8e <Cy_SCB_UART_Init+0x7e>
10002c8c:	be01      	bkpt	0x0001

    CY_ASSERT_L2(CY_SCB_UART_IS_MUTLI_PROC_VALID  (config->enableMutliProcessorMode, config->uartMode, config->dataWidth, config->parity));
10002c8e:	7c88      	ldrb	r0, [r1, #18]
10002c90:	b130      	cbz	r0, 10002ca0 <Cy_SCB_UART_Init+0x90>
10002c92:	7808      	ldrb	r0, [r1, #0]
10002c94:	b918      	cbnz	r0, 10002c9e <Cy_SCB_UART_Init+0x8e>
10002c96:	6888      	ldr	r0, [r1, #8]
10002c98:	2809      	cmp	r0, #9
10002c9a:	f000 8082 	beq.w	10002da2 <Cy_SCB_UART_Init+0x192>
10002c9e:	be01      	bkpt	0x0001

    CY_ASSERT_L2(CY_SCB_IS_INTR_VALID(config->rxFifoIntEnableMask, CY_SCB_UART_RX_INTR_MASK));
10002ca0:	6b48      	ldr	r0, [r1, #52]	; 0x34
10002ca2:	f420 6036 	bic.w	r0, r0, #2912	; 0xb60
10002ca6:	f020 000d 	bic.w	r0, r0, #13
10002caa:	b100      	cbz	r0, 10002cae <Cy_SCB_UART_Init+0x9e>
10002cac:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_IS_INTR_VALID(config->txFifoIntEnableMask, CY_SCB_UART_TX_INTR_MASK));
10002cae:	6bc8      	ldr	r0, [r1, #60]	; 0x3c
10002cb0:	f420 60ee 	bic.w	r0, r0, #1904	; 0x770
10002cb4:	f020 0003 	bic.w	r0, r0, #3
10002cb8:	b100      	cbz	r0, 10002cbc <Cy_SCB_UART_Init+0xac>
10002cba:	be01      	bkpt	0x0001

    uint32_t ovs;

    if ((CY_SCB_UART_IRDA == config->uartMode) && (!config->irdaEnableLowPowerReceiver))
10002cbc:	7808      	ldrb	r0, [r1, #0]
10002cbe:	2802      	cmp	r0, #2
10002cc0:	d074      	beq.n	10002dac <Cy_SCB_UART_Init+0x19c>
        /* For Normal IrDA mode oversampling is always zero */
        ovs = 0UL;
    }
    else
    {
        ovs = (config->oversample - 1UL);
10002cc2:	6848      	ldr	r0, [r1, #4]
10002cc4:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)                      |
                 _VAL2FLD(SCB_CTRL_MEM_WIDTH, ((config->dataWidth <= CY_SCB_BYTE_WIDTH)? 0UL:1UL))  |
                 _VAL2FLD(SCB_CTRL_OVS, ovs)                                                        |
                 _VAL2FLD(SCB_CTRL_MODE, CY_SCB_CTRL_MODE_UART);
#elif(CY_IP_MXSCB_VERSION==1)
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)               |
10002cc8:	7f08      	ldrb	r0, [r1, #28]
10002cca:	2800      	cmp	r0, #0
10002ccc:	d074      	beq.n	10002db8 <Cy_SCB_UART_Init+0x1a8>
10002cce:	f44f 3080 	mov.w	r0, #65536	; 0x10000
                 _BOOL2FLD(SCB_CTRL_BYTE_MODE, (config->dataWidth <= CY_SCB_BYTE_WIDTH)) |
10002cd2:	688c      	ldr	r4, [r1, #8]
10002cd4:	2c08      	cmp	r4, #8
10002cd6:	d871      	bhi.n	10002dbc <Cy_SCB_UART_Init+0x1ac>
10002cd8:	f44f 6400 	mov.w	r4, #2048	; 0x800
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)               |
10002cdc:	4320      	orrs	r0, r4
                 _VAL2FLD(SCB_CTRL_OVS, ovs)                                             |
10002cde:	f00c 0c0f 	and.w	ip, ip, #15
                 _BOOL2FLD(SCB_CTRL_BYTE_MODE, (config->dataWidth <= CY_SCB_BYTE_WIDTH)) |
10002ce2:	ea40 000c 	orr.w	r0, r0, ip
                 _VAL2FLD(SCB_CTRL_OVS, ovs)                                             |
10002ce6:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)               |
10002cea:	6018      	str	r0, [r3, #0]
                 _VAL2FLD(SCB_CTRL_MODE, CY_SCB_CTRL_MODE_UART);
#endif /* CY_IP_MXSCB_VERSION */
    /* Configure SCB_CTRL.BYTE_MODE then verify levels */
    CY_ASSERT_L2(CY_SCB_IS_TRIGGER_LEVEL_VALID(base, config->rxFifoTriggerLevel));
10002cec:	6b0c      	ldr	r4, [r1, #48]	; 0x30
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
10002cee:	6818      	ldr	r0, [r3, #0]
10002cf0:	f410 6f00 	tst.w	r0, #2048	; 0x800
10002cf4:	d064      	beq.n	10002dc0 <Cy_SCB_UART_Init+0x1b0>
10002cf6:	2080      	movs	r0, #128	; 0x80
10002cf8:	4284      	cmp	r4, r0
10002cfa:	d300      	bcc.n	10002cfe <Cy_SCB_UART_Init+0xee>
10002cfc:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_IS_TRIGGER_LEVEL_VALID(base, config->txFifoTriggerLevel));
10002cfe:	6b8c      	ldr	r4, [r1, #56]	; 0x38
10002d00:	6818      	ldr	r0, [r3, #0]
10002d02:	f410 6f00 	tst.w	r0, #2048	; 0x800
10002d06:	d05d      	beq.n	10002dc4 <Cy_SCB_UART_Init+0x1b4>
10002d08:	2080      	movs	r0, #128	; 0x80
10002d0a:	4284      	cmp	r4, r0
10002d0c:	d300      	bcc.n	10002d10 <Cy_SCB_UART_Init+0x100>
10002d0e:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_IS_TRIGGER_LEVEL_VALID(base, config->rtsRxFifoLevel));
10002d10:	6a4c      	ldr	r4, [r1, #36]	; 0x24
10002d12:	6818      	ldr	r0, [r3, #0]
10002d14:	f410 6f00 	tst.w	r0, #2048	; 0x800
10002d18:	d056      	beq.n	10002dc8 <Cy_SCB_UART_Init+0x1b8>
10002d1a:	2080      	movs	r0, #128	; 0x80
10002d1c:	4284      	cmp	r4, r0
10002d1e:	d300      	bcc.n	10002d22 <Cy_SCB_UART_Init+0x112>
10002d20:	be01      	bkpt	0x0001

    SCB_UART_CTRL(base) = _VAL2FLD(SCB_UART_CTRL_MODE, (uint32_t) config->uartMode);
10002d22:	7808      	ldrb	r0, [r1, #0]
10002d24:	0600      	lsls	r0, r0, #24
10002d26:	f000 7040 	and.w	r0, r0, #50331648	; 0x3000000
10002d2a:	6418      	str	r0, [r3, #64]	; 0x40

    /* Configure the RX direction */
    SCB_UART_RX_CTRL(base) = _BOOL2FLD(SCB_UART_RX_CTRL_POLARITY, config->irdaInvertRx)                  |
10002d2c:	7f48      	ldrb	r0, [r1, #29]
10002d2e:	2800      	cmp	r0, #0
10002d30:	d04c      	beq.n	10002dcc <Cy_SCB_UART_Init+0x1bc>
10002d32:	2040      	movs	r0, #64	; 0x40
                         _BOOL2FLD(SCB_UART_RX_CTRL_MP_MODE, config->enableMutliProcessorMode)       |
10002d34:	7c8c      	ldrb	r4, [r1, #18]
10002d36:	2c00      	cmp	r4, #0
10002d38:	d04a      	beq.n	10002dd0 <Cy_SCB_UART_Init+0x1c0>
10002d3a:	f44f 6480 	mov.w	r4, #1024	; 0x400
    SCB_UART_RX_CTRL(base) = _BOOL2FLD(SCB_UART_RX_CTRL_POLARITY, config->irdaInvertRx)                  |
10002d3e:	4320      	orrs	r0, r4
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_PARITY_ERROR, config->dropOnParityError) |
10002d40:	7c0c      	ldrb	r4, [r1, #16]
10002d42:	2c00      	cmp	r4, #0
10002d44:	d046      	beq.n	10002dd4 <Cy_SCB_UART_Init+0x1c4>
10002d46:	f44f 7480 	mov.w	r4, #256	; 0x100
                         _BOOL2FLD(SCB_UART_RX_CTRL_MP_MODE, config->enableMutliProcessorMode)       |
10002d4a:	4320      	orrs	r0, r4
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_FRAME_ERROR, config->dropOnFrameError)   |
10002d4c:	7c4c      	ldrb	r4, [r1, #17]
10002d4e:	2c00      	cmp	r4, #0
10002d50:	d042      	beq.n	10002dd8 <Cy_SCB_UART_Init+0x1c8>
10002d52:	f44f 7400 	mov.w	r4, #512	; 0x200
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_PARITY_ERROR, config->dropOnParityError) |
10002d56:	4320      	orrs	r0, r4
                         _VAL2FLD(SCB_UART_RX_CTRL_BREAK_WIDTH, (config->breakWidth - 1UL))          |
10002d58:	6acc      	ldr	r4, [r1, #44]	; 0x2c
10002d5a:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
10002d5e:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
10002d62:	f40c 2c70 	and.w	ip, ip, #983040	; 0xf0000
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_FRAME_ERROR, config->dropOnFrameError)   |
10002d66:	ea40 000c 	orr.w	r0, r0, ip
                         _VAL2FLD(SCB_UART_RX_CTRL_STOP_BITS,   ((uint32_t) config->stopBits) - 1UL) |
10002d6a:	f891 c00d 	ldrb.w	ip, [r1, #13]
10002d6e:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
10002d72:	f00c 0c07 	and.w	ip, ip, #7
                         _VAL2FLD(SCB_UART_RX_CTRL_BREAK_WIDTH, (config->breakWidth - 1UL))          |
10002d76:	ea40 000c 	orr.w	r0, r0, ip
                         _VAL2FLD(CY_SCB_UART_RX_CTRL_SET_PARITY, (uint32_t) config->parity);
10002d7a:	f891 c00e 	ldrb.w	ip, [r1, #14]
10002d7e:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
10002d82:	f00c 0c30 	and.w	ip, ip, #48	; 0x30
                         _VAL2FLD(SCB_UART_RX_CTRL_STOP_BITS,   ((uint32_t) config->stopBits) - 1UL) |
10002d86:	ea40 000c 	orr.w	r0, r0, ip
    SCB_UART_RX_CTRL(base) = _BOOL2FLD(SCB_UART_RX_CTRL_POLARITY, config->irdaInvertRx)                  |
10002d8a:	6498      	str	r0, [r3, #72]	; 0x48
#if(CY_IP_MXSCB_VERSION>=2)
    SCB_UART_RX_CTRL(base)|=_BOOL2FLD(SCB_UART_RX_CTRL_BREAK_LEVEL, config->breaklevel);
#endif /* CY_IP_MXSCB_VERSION */

    SCB_RX_CTRL(base) = _BOOL2FLD(SCB_RX_CTRL_MSB_FIRST, config->enableMsbFirst)          |
10002d8c:	7b08      	ldrb	r0, [r1, #12]
10002d8e:	b328      	cbz	r0, 10002ddc <Cy_SCB_UART_Init+0x1cc>
10002d90:	f44f 7080 	mov.w	r0, #256	; 0x100
                    _BOOL2FLD(SCB_RX_CTRL_MEDIAN, ((config->enableInputFilter) || \
10002d94:	7bcc      	ldrb	r4, [r1, #15]
10002d96:	bb1c      	cbnz	r4, 10002de0 <Cy_SCB_UART_Init+0x1d0>
10002d98:	780c      	ldrb	r4, [r1, #0]
10002d9a:	2c02      	cmp	r4, #2
10002d9c:	d048      	beq.n	10002e30 <Cy_SCB_UART_Init+0x220>
10002d9e:	2400      	movs	r4, #0
10002da0:	e020      	b.n	10002de4 <Cy_SCB_UART_Init+0x1d4>
    CY_ASSERT_L2(CY_SCB_UART_IS_MUTLI_PROC_VALID  (config->enableMutliProcessorMode, config->uartMode, config->dataWidth, config->parity));
10002da2:	7b88      	ldrb	r0, [r1, #14]
10002da4:	2800      	cmp	r0, #0
10002da6:	f43f af7b 	beq.w	10002ca0 <Cy_SCB_UART_Init+0x90>
10002daa:	e778      	b.n	10002c9e <Cy_SCB_UART_Init+0x8e>
    if ((CY_SCB_UART_IRDA == config->uartMode) && (!config->irdaEnableLowPowerReceiver))
10002dac:	7f88      	ldrb	r0, [r1, #30]
10002dae:	2800      	cmp	r0, #0
10002db0:	d187      	bne.n	10002cc2 <Cy_SCB_UART_Init+0xb2>
        ovs = 0UL;
10002db2:	f04f 0c00 	mov.w	ip, #0
10002db6:	e787      	b.n	10002cc8 <Cy_SCB_UART_Init+0xb8>
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)               |
10002db8:	2000      	movs	r0, #0
10002dba:	e78a      	b.n	10002cd2 <Cy_SCB_UART_Init+0xc2>
                 _BOOL2FLD(SCB_CTRL_BYTE_MODE, (config->dataWidth <= CY_SCB_BYTE_WIDTH)) |
10002dbc:	2400      	movs	r4, #0
10002dbe:	e78d      	b.n	10002cdc <Cy_SCB_UART_Init+0xcc>
10002dc0:	2040      	movs	r0, #64	; 0x40
10002dc2:	e799      	b.n	10002cf8 <Cy_SCB_UART_Init+0xe8>
10002dc4:	2040      	movs	r0, #64	; 0x40
10002dc6:	e7a0      	b.n	10002d0a <Cy_SCB_UART_Init+0xfa>
10002dc8:	2040      	movs	r0, #64	; 0x40
10002dca:	e7a7      	b.n	10002d1c <Cy_SCB_UART_Init+0x10c>
    SCB_UART_RX_CTRL(base) = _BOOL2FLD(SCB_UART_RX_CTRL_POLARITY, config->irdaInvertRx)                  |
10002dcc:	2000      	movs	r0, #0
10002dce:	e7b1      	b.n	10002d34 <Cy_SCB_UART_Init+0x124>
                         _BOOL2FLD(SCB_UART_RX_CTRL_MP_MODE, config->enableMutliProcessorMode)       |
10002dd0:	2400      	movs	r4, #0
10002dd2:	e7b4      	b.n	10002d3e <Cy_SCB_UART_Init+0x12e>
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_PARITY_ERROR, config->dropOnParityError) |
10002dd4:	2400      	movs	r4, #0
10002dd6:	e7b8      	b.n	10002d4a <Cy_SCB_UART_Init+0x13a>
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_FRAME_ERROR, config->dropOnFrameError)   |
10002dd8:	2400      	movs	r4, #0
10002dda:	e7bc      	b.n	10002d56 <Cy_SCB_UART_Init+0x146>
    SCB_RX_CTRL(base) = _BOOL2FLD(SCB_RX_CTRL_MSB_FIRST, config->enableMsbFirst)          |
10002ddc:	2000      	movs	r0, #0
10002dde:	e7d9      	b.n	10002d94 <Cy_SCB_UART_Init+0x184>
                    _BOOL2FLD(SCB_RX_CTRL_MEDIAN, ((config->enableInputFilter) || \
10002de0:	f44f 7400 	mov.w	r4, #512	; 0x200
    SCB_RX_CTRL(base) = _BOOL2FLD(SCB_RX_CTRL_MSB_FIRST, config->enableMsbFirst)          |
10002de4:	4320      	orrs	r0, r4
                                             (config->uartMode == CY_SCB_UART_IRDA))) |
                    _VAL2FLD(SCB_RX_CTRL_DATA_WIDTH, (config->dataWidth - 1UL));
10002de6:	688c      	ldr	r4, [r1, #8]
10002de8:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
10002dec:	f00c 0c0f 	and.w	ip, ip, #15
                                             (config->uartMode == CY_SCB_UART_IRDA))) |
10002df0:	ea40 000c 	orr.w	r0, r0, ip
    SCB_RX_CTRL(base) = _BOOL2FLD(SCB_RX_CTRL_MSB_FIRST, config->enableMsbFirst)          |
10002df4:	f8c3 0300 	str.w	r0, [r3, #768]	; 0x300

    SCB_RX_MATCH(base) = _VAL2FLD(SCB_RX_MATCH_ADDR, config->receiverAddress) |
10002df8:	f891 c014 	ldrb.w	ip, [r1, #20]
                     _VAL2FLD(SCB_RX_MATCH_MASK, config->receiverAddressMask);
10002dfc:	6988      	ldr	r0, [r1, #24]
10002dfe:	0400      	lsls	r0, r0, #16
10002e00:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
    SCB_RX_MATCH(base) = _VAL2FLD(SCB_RX_MATCH_ADDR, config->receiverAddress) |
10002e04:	ea4c 0000 	orr.w	r0, ip, r0
10002e08:	f8c3 0310 	str.w	r0, [r3, #784]	; 0x310

    /* Configure SCB_CTRL.RX_CTRL then verify break width */
    CY_ASSERT_L2(CY_SCB_UART_IS_RX_BREAK_WIDTH_VALID(base, config->breakWidth));
10002e0c:	6acc      	ldr	r4, [r1, #44]	; 0x2c
10002e0e:	f8d3 0300 	ldr.w	r0, [r3, #768]	; 0x300
10002e12:	f000 000f 	and.w	r0, r0, #15
10002e16:	3003      	adds	r0, #3
10002e18:	4284      	cmp	r4, r0
10002e1a:	d301      	bcc.n	10002e20 <Cy_SCB_UART_Init+0x210>
10002e1c:	2c10      	cmp	r4, #16
10002e1e:	d900      	bls.n	10002e22 <Cy_SCB_UART_Init+0x212>
10002e20:	be01      	bkpt	0x0001

    /* Configure the TX direction */
    SCB_UART_TX_CTRL(base) = _BOOL2FLD(SCB_UART_TX_CTRL_RETRY_ON_NACK, ((config->smartCardRetryOnNack) && \
10002e22:	7fc8      	ldrb	r0, [r1, #31]
10002e24:	b138      	cbz	r0, 10002e36 <Cy_SCB_UART_Init+0x226>
10002e26:	7808      	ldrb	r0, [r1, #0]
10002e28:	2801      	cmp	r0, #1
10002e2a:	d063      	beq.n	10002ef4 <Cy_SCB_UART_Init+0x2e4>
10002e2c:	2400      	movs	r4, #0
10002e2e:	e003      	b.n	10002e38 <Cy_SCB_UART_Init+0x228>
                    _BOOL2FLD(SCB_RX_CTRL_MEDIAN, ((config->enableInputFilter) || \
10002e30:	f44f 7400 	mov.w	r4, #512	; 0x200
10002e34:	e7d6      	b.n	10002de4 <Cy_SCB_UART_Init+0x1d4>
    SCB_UART_TX_CTRL(base) = _BOOL2FLD(SCB_UART_TX_CTRL_RETRY_ON_NACK, ((config->smartCardRetryOnNack) && \
10002e36:	2400      	movs	r4, #0
                                                              (config->uartMode == CY_SCB_UART_SMARTCARD))) |
                         _VAL2FLD(SCB_UART_TX_CTRL_STOP_BITS, ((uint32_t) config->stopBits) - 1UL)          |
10002e38:	7b48      	ldrb	r0, [r1, #13]
10002e3a:	3801      	subs	r0, #1
10002e3c:	f000 0007 	and.w	r0, r0, #7
                                                              (config->uartMode == CY_SCB_UART_SMARTCARD))) |
10002e40:	4320      	orrs	r0, r4
                         _VAL2FLD(CY_SCB_UART_TX_CTRL_SET_PARITY, (uint32_t) config->parity);
10002e42:	f891 c00e 	ldrb.w	ip, [r1, #14]
10002e46:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
10002e4a:	f00c 0c30 	and.w	ip, ip, #48	; 0x30
                         _VAL2FLD(SCB_UART_TX_CTRL_STOP_BITS, ((uint32_t) config->stopBits) - 1UL)          |
10002e4e:	ea40 000c 	orr.w	r0, r0, ip
    SCB_UART_TX_CTRL(base) = _BOOL2FLD(SCB_UART_TX_CTRL_RETRY_ON_NACK, ((config->smartCardRetryOnNack) && \
10002e52:	6458      	str	r0, [r3, #68]	; 0x44

    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
10002e54:	7b08      	ldrb	r0, [r1, #12]
10002e56:	2800      	cmp	r0, #0
10002e58:	d04f      	beq.n	10002efa <Cy_SCB_UART_Init+0x2ea>
10002e5a:	f44f 7480 	mov.w	r4, #256	; 0x100
                     _VAL2FLD(SCB_TX_CTRL_DATA_WIDTH,  (config->dataWidth - 1UL)) |
10002e5e:	6888      	ldr	r0, [r1, #8]
10002e60:	3801      	subs	r0, #1
10002e62:	f000 000f 	and.w	r0, r0, #15
    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
10002e66:	4320      	orrs	r0, r4
                     _BOOL2FLD(SCB_TX_CTRL_OPEN_DRAIN, (config->uartMode == CY_SCB_UART_SMARTCARD));
10002e68:	780c      	ldrb	r4, [r1, #0]
10002e6a:	2c01      	cmp	r4, #1
10002e6c:	d047      	beq.n	10002efe <Cy_SCB_UART_Init+0x2ee>
10002e6e:	2400      	movs	r4, #0
                     _VAL2FLD(SCB_TX_CTRL_DATA_WIDTH,  (config->dataWidth - 1UL)) |
10002e70:	4320      	orrs	r0, r4
    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
10002e72:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200

    SCB_RX_FIFO_CTRL(base) = _VAL2FLD(SCB_RX_FIFO_CTRL_TRIGGER_LEVEL, config->rxFifoTriggerLevel);
10002e76:	f891 0030 	ldrb.w	r0, [r1, #48]	; 0x30
10002e7a:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304

    /* Configure the flow control */
    SCB_UART_FLOW_CTRL(base) = _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_ENABLED, config->enableCts) |
10002e7e:	f891 0020 	ldrb.w	r0, [r1, #32]
10002e82:	2800      	cmp	r0, #0
10002e84:	d03e      	beq.n	10002f04 <Cy_SCB_UART_Init+0x2f4>
10002e86:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->ctsPolarity)) |
10002e8a:	f891 4021 	ldrb.w	r4, [r1, #33]	; 0x21
10002e8e:	2c01      	cmp	r4, #1
10002e90:	d03a      	beq.n	10002f08 <Cy_SCB_UART_Init+0x2f8>
10002e92:	2400      	movs	r4, #0
    SCB_UART_FLOW_CTRL(base) = _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_ENABLED, config->enableCts) |
10002e94:	4320      	orrs	r0, r4
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_RTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->rtsPolarity)) |
10002e96:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
10002e9a:	2c01      	cmp	r4, #1
10002e9c:	d037      	beq.n	10002f0e <Cy_SCB_UART_Init+0x2fe>
10002e9e:	2400      	movs	r4, #0
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->ctsPolarity)) |
10002ea0:	4320      	orrs	r0, r4
                           _VAL2FLD(SCB_UART_FLOW_CTRL_TRIGGER_LEVEL, config->rtsRxFifoLevel);
10002ea2:	f891 4024 	ldrb.w	r4, [r1, #36]	; 0x24
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_RTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->rtsPolarity)) |
10002ea6:	4320      	orrs	r0, r4
    SCB_UART_FLOW_CTRL(base) = _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_ENABLED, config->enableCts) |
10002ea8:	6518      	str	r0, [r3, #80]	; 0x50

    SCB_TX_FIFO_CTRL(base) = _VAL2FLD(SCB_TX_FIFO_CTRL_TRIGGER_LEVEL, config->txFifoTriggerLevel);
10002eaa:	f891 0038 	ldrb.w	r0, [r1, #56]	; 0x38
10002eae:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204

    /* Set up interrupt sources */
    SCB_INTR_RX_MASK(base) = (config->rxFifoIntEnableMask & CY_SCB_UART_RX_INTR_MASK);
10002eb2:	6b48      	ldr	r0, [r1, #52]	; 0x34
10002eb4:	f420 6092 	bic.w	r0, r0, #1168	; 0x490
10002eb8:	f020 0002 	bic.w	r0, r0, #2
10002ebc:	0500      	lsls	r0, r0, #20
10002ebe:	0d00      	lsrs	r0, r0, #20
10002ec0:	f8c3 0fc8 	str.w	r0, [r3, #4040]	; 0xfc8
    SCB_INTR_TX_MASK(base) = (config->txFifoIntEnableMask & CY_SCB_UART_TX_INTR_MASK);
10002ec4:	6bc8      	ldr	r0, [r1, #60]	; 0x3c
10002ec6:	f020 008c 	bic.w	r0, r0, #140	; 0x8c
10002eca:	0540      	lsls	r0, r0, #21
10002ecc:	0d40      	lsrs	r0, r0, #21
10002ece:	f8c3 0f88 	str.w	r0, [r3, #3976]	; 0xf88

    /* Initialize context */
    if (NULL != context)
10002ed2:	b31a      	cbz	r2, 10002f1c <Cy_SCB_UART_Init+0x30c>
    {
        context->rxStatus  = 0UL;
10002ed4:	2000      	movs	r0, #0
10002ed6:	6050      	str	r0, [r2, #4]
        context->txStatus  = 0UL;
10002ed8:	6010      	str	r0, [r2, #0]

        context->rxRingBuf = NULL;
10002eda:	6090      	str	r0, [r2, #8]
        context->rxRingBufSize = 0UL;
10002edc:	60d0      	str	r0, [r2, #12]

        context->rxBufIdx  = 0UL;
10002ede:	6210      	str	r0, [r2, #32]
        context->txLeftToTransmit = 0UL;
10002ee0:	62d0      	str	r0, [r2, #44]	; 0x2c

        context->cbEvents = NULL;
10002ee2:	6350      	str	r0, [r2, #52]	; 0x34
        context->irdaEnableLowPowerReceiver = config->irdaEnableLowPowerReceiver;
10002ee4:	7f8b      	ldrb	r3, [r1, #30]
10002ee6:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

    #if !defined(NDEBUG)
        /* Put an initialization key into the initKey variable to verify
        * context initialization in the transfer API.
        */
        context->initKey = CY_SCB_UART_INIT_KEY;
10002eea:	4b0d      	ldr	r3, [pc, #52]	; (10002f20 <Cy_SCB_UART_Init+0x310>)
10002eec:	6393      	str	r3, [r2, #56]	; 0x38
    #endif /* !(NDEBUG) */
    }

    return CY_SCB_UART_SUCCESS;
}
10002eee:	f85d 4b04 	ldr.w	r4, [sp], #4
10002ef2:	4770      	bx	lr
    SCB_UART_TX_CTRL(base) = _BOOL2FLD(SCB_UART_TX_CTRL_RETRY_ON_NACK, ((config->smartCardRetryOnNack) && \
10002ef4:	f44f 7480 	mov.w	r4, #256	; 0x100
10002ef8:	e79e      	b.n	10002e38 <Cy_SCB_UART_Init+0x228>
    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
10002efa:	2400      	movs	r4, #0
10002efc:	e7af      	b.n	10002e5e <Cy_SCB_UART_Init+0x24e>
                     _BOOL2FLD(SCB_TX_CTRL_OPEN_DRAIN, (config->uartMode == CY_SCB_UART_SMARTCARD));
10002efe:	f44f 3480 	mov.w	r4, #65536	; 0x10000
10002f02:	e7b5      	b.n	10002e70 <Cy_SCB_UART_Init+0x260>
    SCB_UART_FLOW_CTRL(base) = _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_ENABLED, config->enableCts) |
10002f04:	2000      	movs	r0, #0
10002f06:	e7c0      	b.n	10002e8a <Cy_SCB_UART_Init+0x27a>
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->ctsPolarity)) |
10002f08:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
10002f0c:	e7c2      	b.n	10002e94 <Cy_SCB_UART_Init+0x284>
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_RTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->rtsPolarity)) |
10002f0e:	f44f 3480 	mov.w	r4, #65536	; 0x10000
10002f12:	e7c5      	b.n	10002ea0 <Cy_SCB_UART_Init+0x290>
        return CY_SCB_UART_BAD_PARAM;
10002f14:	4803      	ldr	r0, [pc, #12]	; (10002f24 <Cy_SCB_UART_Init+0x314>)
10002f16:	4770      	bx	lr
10002f18:	4802      	ldr	r0, [pc, #8]	; (10002f24 <Cy_SCB_UART_Init+0x314>)
}
10002f1a:	4770      	bx	lr
    return CY_SCB_UART_SUCCESS;
10002f1c:	2000      	movs	r0, #0
10002f1e:	e7e6      	b.n	10002eee <Cy_SCB_UART_Init+0x2de>
10002f20:	00abcdef 	.word	0x00abcdef
10002f24:	00aa6001 	.word	0x00aa6001

10002f28 <main>:

* Return:
*  Does not return.
*****************************************************************************/
int main(void)
{
10002f28:	b570      	push	{r4, r5, r6, lr}

    cy_rslt_t result;


    /* Connect assigned divider to be a clock source for UART */
    Cy_SysClk_PeriphAssignDivider(UART_CLK, UART_CLK_DIV_TYPE, UART_CLK_DIV_NUMBER);
10002f2a:	2200      	movs	r2, #0
10002f2c:	2101      	movs	r1, #1
10002f2e:	2005      	movs	r0, #5
10002f30:	f7ff fbb8 	bl	100026a4 <Cy_SysClk_PeriphAssignDivider>
    /* UART desired baud rate is 115200 bps (Standard mode).
    * The UART baud rate = (clk_scb / Oversample).
    * For clk_peri = 50 MHz, select divider value 36 and get SCB clock = (50 MHz / 36) = 1,389 MHz.
    * Select Oversample = 12. These setting results UART data rate = 1,389 MHz / 12 = 115750 bps.
    */
    Cy_SysClk_PeriphSetDivider   (UART_CLK_DIV_TYPE, UART_CLK_DIV_NUMBER, 35UL);
10002f34:	2223      	movs	r2, #35	; 0x23
10002f36:	2100      	movs	r1, #0
10002f38:	2001      	movs	r0, #1
10002f3a:	f7ff fb71 	bl	10002620 <Cy_SysClk_PeriphSetDivider>
    Cy_SysClk_PeriphEnableDivider(UART_CLK_DIV_TYPE, UART_CLK_DIV_NUMBER);
10002f3e:	2100      	movs	r1, #0
10002f40:	2001      	movs	r0, #1
10002f42:	f7ff fbeb 	bl	1000271c <Cy_SysClk_PeriphEnableDivider>

    /* Connect SCB5 UART function to pins */
    Cy_GPIO_SetHSIOM(UART_PORT, UART_RX_NUM, P5_0_SCB5_UART_RX);
10002f46:	4c1d      	ldr	r4, [pc, #116]	; (10002fbc <main+0x94>)
10002f48:	2212      	movs	r2, #18
10002f4a:	2100      	movs	r1, #0
10002f4c:	4620      	mov	r0, r4
10002f4e:	f7ff fa9f 	bl	10002490 <Cy_GPIO_SetHSIOM>
    Cy_GPIO_SetHSIOM(UART_PORT, UART_TX_NUM, P5_1_SCB5_UART_TX);
10002f52:	2212      	movs	r2, #18
10002f54:	2101      	movs	r1, #1
10002f56:	4620      	mov	r0, r4
10002f58:	f7ff fa9a 	bl	10002490 <Cy_GPIO_SetHSIOM>

    /* Configure pins for UART operation */
    Cy_GPIO_SetDrivemode(UART_PORT, UART_RX_NUM, CY_GPIO_DM_HIGHZ);
10002f5c:	2208      	movs	r2, #8
10002f5e:	2100      	movs	r1, #0
10002f60:	4620      	mov	r0, r4
10002f62:	f7ff facd 	bl	10002500 <Cy_GPIO_SetDrivemode>
    Cy_GPIO_SetDrivemode(UART_PORT, UART_TX_NUM, CY_GPIO_DM_STRONG_IN_OFF);
10002f66:	2206      	movs	r2, #6
10002f68:	2101      	movs	r1, #1
10002f6a:	4620      	mov	r0, r4
10002f6c:	f7ff fac8 	bl	10002500 <Cy_GPIO_SetDrivemode>
    
    Cy_SCB_UART_Init(UART, &uartConfig, &uartContext);
10002f70:	4c13      	ldr	r4, [pc, #76]	; (10002fc0 <main+0x98>)
10002f72:	4a14      	ldr	r2, [pc, #80]	; (10002fc4 <main+0x9c>)
10002f74:	4914      	ldr	r1, [pc, #80]	; (10002fc8 <main+0xa0>)
10002f76:	4620      	mov	r0, r4
10002f78:	f7ff fe4a 	bl	10002c10 <Cy_SCB_UART_Init>
* The pointer to the UART SCB instance.
*
*******************************************************************************/
__STATIC_INLINE void Cy_SCB_UART_Enable(CySCB_Type *base)
{
    SCB_CTRL(base) |= SCB_CTRL_ENABLED_Msk;
10002f7c:	6823      	ldr	r3, [r4, #0]
10002f7e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10002f82:	6023      	str	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
10002f84:	b662      	cpsie	i

    Cy_SCB_UART_Enable(UART);

    /* Enable global interrupts */
    __enable_irq();
    uint32_t count = 0;
10002f86:	2500      	movs	r5, #0
10002f88:	e011      	b.n	10002fae <main+0x86>
*******************************************************************************/
__STATIC_INLINE void Cy_SCB_UART_PutString(CySCB_Type *base, char_t const string[])
{
    CY_ASSERT_L1(CY_SCB_IS_BUFFER_VALID(string, 1UL));

    Cy_SCB_WriteString(base, string);
10002f8a:	4c0d      	ldr	r4, [pc, #52]	; (10002fc0 <main+0x98>)
10002f8c:	4620      	mov	r0, r4
10002f8e:	f7ff fe22 	bl	10002bd6 <Cy_SCB_WriteString>

     while(1)
    {
        Cy_SCB_UART_PutString(UART, string);
        Cy_SCB_UART_Put(UART, count++);
10002f92:	1c6e      	adds	r6, r5, #1
    return Cy_SCB_Write(base, data);
10002f94:	4629      	mov	r1, r5
10002f96:	4620      	mov	r0, r4
10002f98:	f7ff fe0a 	bl	10002bb0 <Cy_SCB_Write>
    Cy_SCB_WriteString(base, string);
10002f9c:	490b      	ldr	r1, [pc, #44]	; (10002fcc <main+0xa4>)
10002f9e:	4620      	mov	r0, r4
10002fa0:	f7ff fe19 	bl	10002bd6 <Cy_SCB_WriteString>
        Cy_SCB_UART_PutString(UART, "\n");
        Cy_SysLib_Delay(1000);
10002fa4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
10002fa8:	f7ff face 	bl	10002548 <Cy_SysLib_Delay>
        Cy_SCB_UART_Put(UART, count++);
10002fac:	4635      	mov	r5, r6
        Cy_SCB_UART_PutString(UART, string);
10002fae:	4b08      	ldr	r3, [pc, #32]	; (10002fd0 <main+0xa8>)
10002fb0:	6819      	ldr	r1, [r3, #0]
    CY_ASSERT_L1(CY_SCB_IS_BUFFER_VALID(string, 1UL));
10002fb2:	2900      	cmp	r1, #0
10002fb4:	d1e9      	bne.n	10002f8a <main+0x62>
10002fb6:	be01      	bkpt	0x0001
}
10002fb8:	e7e7      	b.n	10002f8a <main+0x62>
10002fba:	bf00      	nop
10002fbc:	40310280 	.word	0x40310280
10002fc0:	40650000 	.word	0x40650000
10002fc4:	080023c4 	.word	0x080023c4
10002fc8:	10003434 	.word	0x10003434
10002fcc:	10003420 	.word	0x10003420
10002fd0:	080022f8 	.word	0x080022f8

10002fd4 <__aeabi_uldivmod>:
10002fd4:	b953      	cbnz	r3, 10002fec <__aeabi_uldivmod+0x18>
10002fd6:	b94a      	cbnz	r2, 10002fec <__aeabi_uldivmod+0x18>
10002fd8:	2900      	cmp	r1, #0
10002fda:	bf08      	it	eq
10002fdc:	2800      	cmpeq	r0, #0
10002fde:	bf1c      	itt	ne
10002fe0:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
10002fe4:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
10002fe8:	f000 b974 	b.w	100032d4 <__aeabi_idiv0>
10002fec:	f1ad 0c08 	sub.w	ip, sp, #8
10002ff0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
10002ff4:	f000 f806 	bl	10003004 <__udivmoddi4>
10002ff8:	f8dd e004 	ldr.w	lr, [sp, #4]
10002ffc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
10003000:	b004      	add	sp, #16
10003002:	4770      	bx	lr

10003004 <__udivmoddi4>:
10003004:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
10003008:	9e08      	ldr	r6, [sp, #32]
1000300a:	460d      	mov	r5, r1
1000300c:	4604      	mov	r4, r0
1000300e:	4688      	mov	r8, r1
10003010:	2b00      	cmp	r3, #0
10003012:	d14d      	bne.n	100030b0 <__udivmoddi4+0xac>
10003014:	428a      	cmp	r2, r1
10003016:	4694      	mov	ip, r2
10003018:	d968      	bls.n	100030ec <__udivmoddi4+0xe8>
1000301a:	fab2 f282 	clz	r2, r2
1000301e:	b152      	cbz	r2, 10003036 <__udivmoddi4+0x32>
10003020:	fa01 f302 	lsl.w	r3, r1, r2
10003024:	f1c2 0120 	rsb	r1, r2, #32
10003028:	fa20 f101 	lsr.w	r1, r0, r1
1000302c:	fa0c fc02 	lsl.w	ip, ip, r2
10003030:	ea41 0803 	orr.w	r8, r1, r3
10003034:	4094      	lsls	r4, r2
10003036:	ea4f 451c 	mov.w	r5, ip, lsr #16
1000303a:	0c21      	lsrs	r1, r4, #16
1000303c:	fbb8 fef5 	udiv	lr, r8, r5
10003040:	fa1f f78c 	uxth.w	r7, ip
10003044:	fb05 831e 	mls	r3, r5, lr, r8
10003048:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
1000304c:	fb0e f107 	mul.w	r1, lr, r7
10003050:	4299      	cmp	r1, r3
10003052:	d90b      	bls.n	1000306c <__udivmoddi4+0x68>
10003054:	eb1c 0303 	adds.w	r3, ip, r3
10003058:	f10e 30ff 	add.w	r0, lr, #4294967295	; 0xffffffff
1000305c:	f080 811e 	bcs.w	1000329c <__udivmoddi4+0x298>
10003060:	4299      	cmp	r1, r3
10003062:	f240 811b 	bls.w	1000329c <__udivmoddi4+0x298>
10003066:	f1ae 0e02 	sub.w	lr, lr, #2
1000306a:	4463      	add	r3, ip
1000306c:	1a5b      	subs	r3, r3, r1
1000306e:	b2a4      	uxth	r4, r4
10003070:	fbb3 f0f5 	udiv	r0, r3, r5
10003074:	fb05 3310 	mls	r3, r5, r0, r3
10003078:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
1000307c:	fb00 f707 	mul.w	r7, r0, r7
10003080:	42a7      	cmp	r7, r4
10003082:	d90a      	bls.n	1000309a <__udivmoddi4+0x96>
10003084:	eb1c 0404 	adds.w	r4, ip, r4
10003088:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
1000308c:	f080 8108 	bcs.w	100032a0 <__udivmoddi4+0x29c>
10003090:	42a7      	cmp	r7, r4
10003092:	f240 8105 	bls.w	100032a0 <__udivmoddi4+0x29c>
10003096:	4464      	add	r4, ip
10003098:	3802      	subs	r0, #2
1000309a:	1be4      	subs	r4, r4, r7
1000309c:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
100030a0:	2100      	movs	r1, #0
100030a2:	b11e      	cbz	r6, 100030ac <__udivmoddi4+0xa8>
100030a4:	40d4      	lsrs	r4, r2
100030a6:	2300      	movs	r3, #0
100030a8:	e9c6 4300 	strd	r4, r3, [r6]
100030ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
100030b0:	428b      	cmp	r3, r1
100030b2:	d908      	bls.n	100030c6 <__udivmoddi4+0xc2>
100030b4:	2e00      	cmp	r6, #0
100030b6:	f000 80ee 	beq.w	10003296 <__udivmoddi4+0x292>
100030ba:	2100      	movs	r1, #0
100030bc:	e9c6 0500 	strd	r0, r5, [r6]
100030c0:	4608      	mov	r0, r1
100030c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
100030c6:	fab3 f183 	clz	r1, r3
100030ca:	2900      	cmp	r1, #0
100030cc:	d14a      	bne.n	10003164 <__udivmoddi4+0x160>
100030ce:	42ab      	cmp	r3, r5
100030d0:	d302      	bcc.n	100030d8 <__udivmoddi4+0xd4>
100030d2:	4282      	cmp	r2, r0
100030d4:	f200 80f9 	bhi.w	100032ca <__udivmoddi4+0x2c6>
100030d8:	1a84      	subs	r4, r0, r2
100030da:	eb65 0303 	sbc.w	r3, r5, r3
100030de:	2001      	movs	r0, #1
100030e0:	4698      	mov	r8, r3
100030e2:	2e00      	cmp	r6, #0
100030e4:	d0e2      	beq.n	100030ac <__udivmoddi4+0xa8>
100030e6:	e9c6 4800 	strd	r4, r8, [r6]
100030ea:	e7df      	b.n	100030ac <__udivmoddi4+0xa8>
100030ec:	b902      	cbnz	r2, 100030f0 <__udivmoddi4+0xec>
100030ee:	deff      	udf	#255	; 0xff
100030f0:	fab2 f282 	clz	r2, r2
100030f4:	2a00      	cmp	r2, #0
100030f6:	f040 8091 	bne.w	1000321c <__udivmoddi4+0x218>
100030fa:	eba1 050c 	sub.w	r5, r1, ip
100030fe:	ea4f 471c 	mov.w	r7, ip, lsr #16
10003102:	fa1f fe8c 	uxth.w	lr, ip
10003106:	2101      	movs	r1, #1
10003108:	fbb5 f3f7 	udiv	r3, r5, r7
1000310c:	fb07 5013 	mls	r0, r7, r3, r5
10003110:	0c25      	lsrs	r5, r4, #16
10003112:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
10003116:	fb0e f003 	mul.w	r0, lr, r3
1000311a:	42a8      	cmp	r0, r5
1000311c:	d908      	bls.n	10003130 <__udivmoddi4+0x12c>
1000311e:	eb1c 0505 	adds.w	r5, ip, r5
10003122:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
10003126:	d202      	bcs.n	1000312e <__udivmoddi4+0x12a>
10003128:	42a8      	cmp	r0, r5
1000312a:	f200 80cb 	bhi.w	100032c4 <__udivmoddi4+0x2c0>
1000312e:	4643      	mov	r3, r8
10003130:	1a2d      	subs	r5, r5, r0
10003132:	b2a4      	uxth	r4, r4
10003134:	fbb5 f0f7 	udiv	r0, r5, r7
10003138:	fb07 5510 	mls	r5, r7, r0, r5
1000313c:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
10003140:	fb0e fe00 	mul.w	lr, lr, r0
10003144:	45a6      	cmp	lr, r4
10003146:	d908      	bls.n	1000315a <__udivmoddi4+0x156>
10003148:	eb1c 0404 	adds.w	r4, ip, r4
1000314c:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
10003150:	d202      	bcs.n	10003158 <__udivmoddi4+0x154>
10003152:	45a6      	cmp	lr, r4
10003154:	f200 80bb 	bhi.w	100032ce <__udivmoddi4+0x2ca>
10003158:	4628      	mov	r0, r5
1000315a:	eba4 040e 	sub.w	r4, r4, lr
1000315e:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
10003162:	e79e      	b.n	100030a2 <__udivmoddi4+0x9e>
10003164:	f1c1 0720 	rsb	r7, r1, #32
10003168:	408b      	lsls	r3, r1
1000316a:	fa22 fc07 	lsr.w	ip, r2, r7
1000316e:	ea4c 0c03 	orr.w	ip, ip, r3
10003172:	fa20 f407 	lsr.w	r4, r0, r7
10003176:	fa05 f301 	lsl.w	r3, r5, r1
1000317a:	431c      	orrs	r4, r3
1000317c:	40fd      	lsrs	r5, r7
1000317e:	ea4f 491c 	mov.w	r9, ip, lsr #16
10003182:	fa00 f301 	lsl.w	r3, r0, r1
10003186:	fbb5 f8f9 	udiv	r8, r5, r9
1000318a:	0c20      	lsrs	r0, r4, #16
1000318c:	fa1f fe8c 	uxth.w	lr, ip
10003190:	fb09 5518 	mls	r5, r9, r8, r5
10003194:	ea40 4505 	orr.w	r5, r0, r5, lsl #16
10003198:	fb08 f00e 	mul.w	r0, r8, lr
1000319c:	42a8      	cmp	r0, r5
1000319e:	fa02 f201 	lsl.w	r2, r2, r1
100031a2:	d90b      	bls.n	100031bc <__udivmoddi4+0x1b8>
100031a4:	eb1c 0505 	adds.w	r5, ip, r5
100031a8:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
100031ac:	f080 8088 	bcs.w	100032c0 <__udivmoddi4+0x2bc>
100031b0:	42a8      	cmp	r0, r5
100031b2:	f240 8085 	bls.w	100032c0 <__udivmoddi4+0x2bc>
100031b6:	f1a8 0802 	sub.w	r8, r8, #2
100031ba:	4465      	add	r5, ip
100031bc:	1a2d      	subs	r5, r5, r0
100031be:	b2a4      	uxth	r4, r4
100031c0:	fbb5 f0f9 	udiv	r0, r5, r9
100031c4:	fb09 5510 	mls	r5, r9, r0, r5
100031c8:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
100031cc:	fb00 fe0e 	mul.w	lr, r0, lr
100031d0:	45ae      	cmp	lr, r5
100031d2:	d908      	bls.n	100031e6 <__udivmoddi4+0x1e2>
100031d4:	eb1c 0505 	adds.w	r5, ip, r5
100031d8:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
100031dc:	d26c      	bcs.n	100032b8 <__udivmoddi4+0x2b4>
100031de:	45ae      	cmp	lr, r5
100031e0:	d96a      	bls.n	100032b8 <__udivmoddi4+0x2b4>
100031e2:	3802      	subs	r0, #2
100031e4:	4465      	add	r5, ip
100031e6:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
100031ea:	fba0 9402 	umull	r9, r4, r0, r2
100031ee:	eba5 050e 	sub.w	r5, r5, lr
100031f2:	42a5      	cmp	r5, r4
100031f4:	46c8      	mov	r8, r9
100031f6:	46a6      	mov	lr, r4
100031f8:	d356      	bcc.n	100032a8 <__udivmoddi4+0x2a4>
100031fa:	d053      	beq.n	100032a4 <__udivmoddi4+0x2a0>
100031fc:	b15e      	cbz	r6, 10003216 <__udivmoddi4+0x212>
100031fe:	ebb3 0208 	subs.w	r2, r3, r8
10003202:	eb65 050e 	sbc.w	r5, r5, lr
10003206:	fa05 f707 	lsl.w	r7, r5, r7
1000320a:	fa22 f301 	lsr.w	r3, r2, r1
1000320e:	40cd      	lsrs	r5, r1
10003210:	431f      	orrs	r7, r3
10003212:	e9c6 7500 	strd	r7, r5, [r6]
10003216:	2100      	movs	r1, #0
10003218:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1000321c:	f1c2 0320 	rsb	r3, r2, #32
10003220:	fa20 f103 	lsr.w	r1, r0, r3
10003224:	fa0c fc02 	lsl.w	ip, ip, r2
10003228:	fa25 f303 	lsr.w	r3, r5, r3
1000322c:	4095      	lsls	r5, r2
1000322e:	430d      	orrs	r5, r1
10003230:	ea4f 471c 	mov.w	r7, ip, lsr #16
10003234:	fa1f fe8c 	uxth.w	lr, ip
10003238:	fbb3 f1f7 	udiv	r1, r3, r7
1000323c:	fb07 3011 	mls	r0, r7, r1, r3
10003240:	0c2b      	lsrs	r3, r5, #16
10003242:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
10003246:	fb01 f00e 	mul.w	r0, r1, lr
1000324a:	4298      	cmp	r0, r3
1000324c:	fa04 f402 	lsl.w	r4, r4, r2
10003250:	d908      	bls.n	10003264 <__udivmoddi4+0x260>
10003252:	eb1c 0303 	adds.w	r3, ip, r3
10003256:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
1000325a:	d22f      	bcs.n	100032bc <__udivmoddi4+0x2b8>
1000325c:	4298      	cmp	r0, r3
1000325e:	d92d      	bls.n	100032bc <__udivmoddi4+0x2b8>
10003260:	3902      	subs	r1, #2
10003262:	4463      	add	r3, ip
10003264:	1a1b      	subs	r3, r3, r0
10003266:	b2ad      	uxth	r5, r5
10003268:	fbb3 f0f7 	udiv	r0, r3, r7
1000326c:	fb07 3310 	mls	r3, r7, r0, r3
10003270:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
10003274:	fb00 f30e 	mul.w	r3, r0, lr
10003278:	42ab      	cmp	r3, r5
1000327a:	d908      	bls.n	1000328e <__udivmoddi4+0x28a>
1000327c:	eb1c 0505 	adds.w	r5, ip, r5
10003280:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
10003284:	d216      	bcs.n	100032b4 <__udivmoddi4+0x2b0>
10003286:	42ab      	cmp	r3, r5
10003288:	d914      	bls.n	100032b4 <__udivmoddi4+0x2b0>
1000328a:	3802      	subs	r0, #2
1000328c:	4465      	add	r5, ip
1000328e:	1aed      	subs	r5, r5, r3
10003290:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
10003294:	e738      	b.n	10003108 <__udivmoddi4+0x104>
10003296:	4631      	mov	r1, r6
10003298:	4630      	mov	r0, r6
1000329a:	e707      	b.n	100030ac <__udivmoddi4+0xa8>
1000329c:	4686      	mov	lr, r0
1000329e:	e6e5      	b.n	1000306c <__udivmoddi4+0x68>
100032a0:	4618      	mov	r0, r3
100032a2:	e6fa      	b.n	1000309a <__udivmoddi4+0x96>
100032a4:	454b      	cmp	r3, r9
100032a6:	d2a9      	bcs.n	100031fc <__udivmoddi4+0x1f8>
100032a8:	ebb9 0802 	subs.w	r8, r9, r2
100032ac:	eb64 0e0c 	sbc.w	lr, r4, ip
100032b0:	3801      	subs	r0, #1
100032b2:	e7a3      	b.n	100031fc <__udivmoddi4+0x1f8>
100032b4:	4640      	mov	r0, r8
100032b6:	e7ea      	b.n	1000328e <__udivmoddi4+0x28a>
100032b8:	4620      	mov	r0, r4
100032ba:	e794      	b.n	100031e6 <__udivmoddi4+0x1e2>
100032bc:	4641      	mov	r1, r8
100032be:	e7d1      	b.n	10003264 <__udivmoddi4+0x260>
100032c0:	46d0      	mov	r8, sl
100032c2:	e77b      	b.n	100031bc <__udivmoddi4+0x1b8>
100032c4:	3b02      	subs	r3, #2
100032c6:	4465      	add	r5, ip
100032c8:	e732      	b.n	10003130 <__udivmoddi4+0x12c>
100032ca:	4608      	mov	r0, r1
100032cc:	e709      	b.n	100030e2 <__udivmoddi4+0xde>
100032ce:	4464      	add	r4, ip
100032d0:	3802      	subs	r0, #2
100032d2:	e742      	b.n	1000315a <__udivmoddi4+0x156>

100032d4 <__aeabi_idiv0>:
100032d4:	4770      	bx	lr
100032d6:	bf00      	nop

100032d8 <__libc_fini_array>:
100032d8:	b538      	push	{r3, r4, r5, lr}
100032da:	4d07      	ldr	r5, [pc, #28]	; (100032f8 <__libc_fini_array+0x20>)
100032dc:	4c07      	ldr	r4, [pc, #28]	; (100032fc <__libc_fini_array+0x24>)
100032de:	1b64      	subs	r4, r4, r5
100032e0:	10a4      	asrs	r4, r4, #2
100032e2:	b91c      	cbnz	r4, 100032ec <__libc_fini_array+0x14>
100032e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
100032e8:	f000 b834 	b.w	10003354 <_fini>
100032ec:	3c01      	subs	r4, #1
100032ee:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
100032f2:	4798      	blx	r3
100032f4:	e7f5      	b.n	100032e2 <__libc_fini_array+0xa>
100032f6:	bf00      	nop
100032f8:	08002300 	.word	0x08002300
100032fc:	08002304 	.word	0x08002304

10003300 <__libc_init_array>:
10003300:	b570      	push	{r4, r5, r6, lr}
10003302:	4d0d      	ldr	r5, [pc, #52]	; (10003338 <__libc_init_array+0x38>)
10003304:	4c0d      	ldr	r4, [pc, #52]	; (1000333c <__libc_init_array+0x3c>)
10003306:	1b64      	subs	r4, r4, r5
10003308:	10a4      	asrs	r4, r4, #2
1000330a:	2600      	movs	r6, #0
1000330c:	42a6      	cmp	r6, r4
1000330e:	d109      	bne.n	10003324 <__libc_init_array+0x24>
10003310:	4d0b      	ldr	r5, [pc, #44]	; (10003340 <__libc_init_array+0x40>)
10003312:	4c0c      	ldr	r4, [pc, #48]	; (10003344 <__libc_init_array+0x44>)
10003314:	f000 f818 	bl	10003348 <_init>
10003318:	1b64      	subs	r4, r4, r5
1000331a:	10a4      	asrs	r4, r4, #2
1000331c:	2600      	movs	r6, #0
1000331e:	42a6      	cmp	r6, r4
10003320:	d105      	bne.n	1000332e <__libc_init_array+0x2e>
10003322:	bd70      	pop	{r4, r5, r6, pc}
10003324:	f855 3b04 	ldr.w	r3, [r5], #4
10003328:	4798      	blx	r3
1000332a:	3601      	adds	r6, #1
1000332c:	e7ee      	b.n	1000330c <__libc_init_array+0xc>
1000332e:	f855 3b04 	ldr.w	r3, [r5], #4
10003332:	4798      	blx	r3
10003334:	3601      	adds	r6, #1
10003336:	e7f2      	b.n	1000331e <__libc_init_array+0x1e>
10003338:	080022fc 	.word	0x080022fc
1000333c:	080022fc 	.word	0x080022fc
10003340:	080022fc 	.word	0x080022fc
10003344:	08002300 	.word	0x08002300

10003348 <_init>:
10003348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000334a:	bf00      	nop
1000334c:	bcf8      	pop	{r3, r4, r5, r6, r7}
1000334e:	bc08      	pop	{r3}
10003350:	469e      	mov	lr, r3
10003352:	4770      	bx	lr

10003354 <_fini>:
10003354:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10003356:	bf00      	nop
10003358:	bcf8      	pop	{r3, r4, r5, r6, r7}
1000335a:	bc08      	pop	{r3}
1000335c:	469e      	mov	lr, r3
1000335e:	4770      	bx	lr

10003360 <cy_deviceIpBlockCfgPSoC6_02>:
10003360:	0000 4020 0000 4024 0000 4000 0000 0000     .. @..$@...@....
10003370:	0000 4023 0000 4030 0000 4031 0000 409f     ..#@..0@..1@...@
10003380:	0000 4022 0000 4010 0000 409d 2020 2020     .."@...@...@    
10003390:	1020 1010 1d10 801d 0017 0075 03ff 0206      .........u.....
100033a0:	0006 0436 2010 0000 c07f 0000 0400 0000     ..6.. ..........
100033b0:	0000 0000 1900 4b32 7d64 0000 0000 8000     ......2Kd}......
100033c0:	0040 0b08 0010 0000 0000 01ff 0220 1f00     @........... ...
100033d0:	8000 0400 08ff 1810 1000 1400 1800 1c00     ................
100033e0:	4440 4c48 0050 0000 1008 0000 0008 0000     @DHLP...........
100033f0:	0004 0000 1004 0000 1200 0000 2104 0000     .............!..
10003400:	2100 0000 1600 0000 1140 0240 13c4 1300     .!......@.@.....
10003410:	1380 13a0 1340 1388 13a8 0020 001c 0000     ....@..... .....
10003420:	000a 0000 6548 6c6c 576f 726f 646c 3a20     ....HelloWorld :
10003430:	0020 0000                                    ...

10003434 <uartConfig>:
10003434:	0000 0000 000c 0000 0008 0000 0200 0000     ................
	...
10003460:	000b 0000 0000 0000 0000 0000 0000 0000     ................
10003470:	0000 0000                                   ....

10003474 <__EH_FRAME_BEGIN__>:
10003474:	0000 0000                                   ....
